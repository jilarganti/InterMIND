---
title: "useRoute"
description: "Композабл useRoute возвращает текущий маршрут."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

::note
В шаблоне Vue-компонента вы можете получить доступ к маршруту, используя `$route`.
::

Композабл `useRoute` является оберткой вокруг одноименного композабла из `vue-router`, предоставляя доступ к текущему маршруту в Nuxt-приложении.

Ключевое отличие заключается в том, что в Nuxt композабл гарантирует обновление маршрута **только после** изменения содержимого страницы после навигации.
В отличие от этого, версия `vue-router` обновляет маршрут **немедленно**, что может привести к проблемам синхронизации между различными частями шаблона,
которые полагаются на метаданные маршрута, например.

## Пример

В следующем примере мы вызываем API через [`useFetch`](/docs/api/composables/use-fetch), используя динамический параметр страницы - `slug` - как часть URL.

```html [~/pages/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data: mountain } = await useFetch(`/api/mountains/${route.params.slug}`)
</script>

<template>
  <div>
    <h1>{{ mountain.title }}</h1>
    <p>{{ mountain.description }}</p>
  </div>
</template>
```

Если вам нужно получить доступ к параметрам запроса маршрута (например, `example` в пути `/test?example=true`), то вы можете использовать `useRoute().query` вместо `useRoute().params`.

## API

Помимо динамических параметров и параметров запроса, `useRoute()` также предоставляет следующие вычисляемые ссылки, связанные с текущим маршрутом:

- `fullPath`: закодированный URL, связанный с текущим маршрутом, который содержит путь, запрос и хеш
- `hash`: декодированная секция хеша URL, которая начинается с #
- `query`: доступ к параметрам запроса маршрута
- `matched`: массив нормализованных совпадающих маршрутов с текущим местоположением маршрута
- `meta`: пользовательские данные, прикрепленные к записи
- `name`: уникальное имя для записи маршрута
- `path`: закодированная секция пути URL
- `redirectedFrom`: местоположение маршрута, к которому была предпринята попытка доступа перед попаданием на текущее местоположение маршрута

## Распространенные ошибки

### Проблемы синхронизации маршрутов

Важно использовать композабл `useRoute()` из Nuxt, а не из `vue-router`, чтобы избежать проблем синхронизации во время навигации по страницам.
Импорт `useRoute` напрямую из `vue-router` обходит реализацию Nuxt.

```ts twoslash
// ❌ не используйте `useRoute` из `vue-router`
// @errors: 2300
import { useRoute } from 'vue-router'
// ✅ используйте композабл `useRoute` из Nuxt
import { useRoute } from '#app'
```

### Вызов `useRoute` в middleware

Использование `useRoute` в middleware не рекомендуется, поскольку это может привести к неожиданному поведению.
В middleware нет концепции "текущего маршрута".
Композабл `useRoute()` следует использовать только в функции setup Vue-компонента или в плагине Nuxt.

::warning
Это также относится к любым композаблам, которые используют `useRoute()` внутри себя.
::

::read-more{to="/docs/4.x/guide/directory-structure/app/middleware"}
Узнайте больше о доступе к маршруту в разделе middleware.
::

### Проблемы гидратации с `route.fullPath`

Браузеры не отправляют [фрагменты URL](https://url.spec.whatwg.org/#concept-url-fragment) (например `#foo`) при выполнении запросов. Поэтому использование `route.fullPath` для воздействия на шаблон может вызвать проблемы гидратации, поскольку это будет включать фрагмент на клиенте, но не на сервере.

:read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/type-aliases/RouteLocationNormalizedLoaded.html"}