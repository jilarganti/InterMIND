---
title: "ES модули"
description: "Nuxt использует нативные ES модули."
---

Это руководство поможет объяснить, что такое ES модули и как сделать Nuxt приложение (или внешнюю библиотеку) совместимым с ESM.

## Предыстория

### Модули CommonJS

CommonJS (CJS) — это формат, введенный Node.js, который позволяет обмениваться функциональностью между изолированными модулями JavaScript ([подробнее](https://nodejs.org/api/modules.html)).
Возможно, вы уже знакомы с этим синтаксисом:

```js
const a = require('./a')

module.exports.a = a
```

Сборщики, такие как webpack и Rollup, поддерживают этот синтаксис и позволяют использовать модули, написанные в CommonJS, в браузере.

### Синтаксис ESM

В большинстве случаев, когда люди говорят о ESM против CJS, они говорят о разном синтаксисе для написания [модулей](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).

```js
import a from './a'

export { a }
```

До того, как ECMAScript Modules (ESM) стали стандартом (это заняло более 10 лет!), инструменты, такие как
[webpack](https://webpack.js.org/guides/ecma-script-modules), и даже языки, такие как TypeScript, начали поддерживать так называемый **синтаксис ESM**.
Однако есть некоторые ключевые различия с фактической спецификацией; вот [полезное объяснение](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive).

### Что такое «нативный» ESM?

Возможно, вы уже давно пишете свое приложение, используя синтаксис ESM. В конце концов, он изначально поддерживается браузером, и в Nuxt 2 мы компилировали весь код, который вы писали, в соответствующий формат (CJS для сервера, ESM для браузера).

При добавлении модулей в ваш пакет все было немного по-другому. Примерная библиотека могла предоставлять как CJS, так и ESM версии, и позволяла нам выбрать, какую из них мы хотим:

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

Таким образом, в Nuxt 2 сборщик (webpack) подключал CJS файл ('main') для серверной сборки и использовал ESM файл ('module') для клиентской сборки.

Однако в последних LTS релизах Node.js теперь возможно [использовать нативный ESM модуль](https://nodejs.org/api/esm.html) внутри Node.js. Это означает, что сам Node.js может обрабатывать JavaScript, используя синтаксис ESM, хотя он не делает этого по умолчанию. Два наиболее распространенных способа включить синтаксис ESM:

- установить `"type": "module"` в вашем `package.json` и продолжать использовать расширение `.js`
- использовать расширения файлов `.mjs` (рекомендуется)

Это то, что мы делаем для Nuxt Nitro; мы выводим файл `.output/server/index.mjs`. Это говорит Node.js рассматривать этот файл как нативный ES модуль.

### Какие импорты являются допустимыми в контексте Node.js?

Когда вы используете `import` для модуля вместо `require`, Node.js разрешает его по-другому. Например, когда вы импортируете `sample-library`, Node.js будет искать не `main`, а `exports` или `module` запись в `package.json` этой библиотеки.

Это также верно для динамических импортов, таких как `const b = await import('sample-library')`.

Node поддерживает следующие виды импортов (см. [документацию](https://nodejs.org/api/packages.html#determining-module-system)):

1. файлы, заканчивающиеся на `.mjs` - ожидается, что они используют синтаксис ESM
1. файлы, заканчивающиеся на `.cjs` - ожидается, что они используют синтаксис CJS
1. файлы, заканчивающиеся на `.js` - ожидается, что они используют синтаксис CJS, если только их `package.json` не содержит `"type": "module"`

### Какие проблемы могут возникнуть?

Долгое время авторы модулей создавали сборки с синтаксисом ESM, но использовали соглашения, такие как `.esm.js` или `.es.js`, которые они добавляли в поле `module` в своем `package.json`. До сих пор это не было проблемой, потому что они использовались только сборщиками, такими как webpack, которым не особенно важно расширение файла.

Однако, если вы попытаетесь импортировать пакет с файлом `.esm.js` в контексте Node.js ESM, это не сработает, и вы получите ошибку, подобную этой:

```bash [Terminal]
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

Вы также можете получить эту ошибку, если у вас есть именованный импорт из сборки с синтаксисом ESM, которую Node.js считает CJS:

```bash [Terminal]
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

## Устранение проблем с ESM

Если вы столкнулись с этими ошибками, проблема почти наверняка связана с внешней библиотекой. Им необходимо [исправить свою библиотеку](#library-author-guide), чтобы она поддерживала импорт в Node.

### Транспиляция библиотек

Тем временем вы можете указать Nuxt не пытаться импортировать эти библиотеки, добавив их в `build.transpile`:

```ts twoslash
export default defineNuxtConfig({
  build: {
    transpile: ['sample-library']
  }
})
```

Возможно, вам _также_ потребуется добавить другие пакеты, которые импортируются этими библиотеками.

### Создание псевдонимов для библиотек

В некоторых случаях вам также может потребоваться вручную создать псевдоним для библиотеки к версии CJS, например:

```ts twoslash
export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js'
  }
})
```

### Экспорт по умолчанию

Зависимость в формате CommonJS может использовать `module.exports` или `exports` для предоставления экспорта по умолчанию:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// или
exports.test = 123
```

Это обычно работает хорошо, если мы используем `require` для такой зависимости:

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[Node.js в нативном режиме ESM](https://nodejs.org/api/esm.html#interoperability-with-commonjs), [typescript с включенным `esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) и сборщики, такие как webpack, предоставляют механизм совместимости, чтобы мы могли импортировать такую библиотеку по умолчанию.
Этот механизм часто называется "interop require default":

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

Однако из-за сложности обнаружения синтаксиса и различных форматов сборки всегда есть вероятность того, что interop по умолчанию не сработает, и мы получим что-то вроде этого:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

Также при использовании синтаксиса динамического импорта (как в файлах CJS, так и в ESM) у нас всегда возникает такая ситуация:

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

В этом случае нам нужно вручную выполнить interop экспорта по умолчанию:

```js
// Статический импорт
import { default as pkg } from 'cjs-pkg'

// Динамический импорт
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

Для обработки более сложных ситуаций и большей безопасности мы рекомендуем и внутренне используем в Nuxt [mlly](https://github.com/unjs/mlly), который может сохранять именованные экспорты.

```js
import { interopDefault } from 'mlly'

// Предполагая, что структура { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## Руководство для авторов библиотек

Хорошая новость заключается в том, что исправить проблемы совместимости с ESM относительно просто. Есть два основных варианта:

1. **Вы можете переименовать ваши ESM файлы так, чтобы они заканчивались на `.mjs`.**

   _Это рекомендуемый и самый простой подход._ Возможно, вам придется разобраться с проблемами зависимостей вашей библиотеки и, возможно, с вашей системой сборки, но в большинстве случаев это должно решить проблему. Также рекомендуется переименовать ваши CJS файлы так, чтобы они заканчивались на `.cjs`, для большей ясности.

1. **Вы можете сделать всю вашу библиотеку только ESM**.

   Это означает установку `"type": "module"` в вашем `package.json` и обеспечение того, чтобы ваша собранная библиотека использовала синтаксис ESM. Однако вы можете столкнуться с проблемами с вашими зависимостями - и этот подход означает, что ваша библиотека может быть использована _только_ в контексте ESM.

### Миграция

Первый шаг от CJS к ESM - это обновление любого использования `require` для использования `import` вместо этого:

::code-group

```js [До]
module.exports = ...

exports.hello = ...
```

```js [После]
export default ...

export const hello = ...
```

::

::code-group

```js [До]
const myLib = require('my-lib')
```

```js [После]
import myLib from 'my-lib'
// или
const myLib = await import('my-lib').then(lib => lib.default || lib)
```

::

В ESM модулях, в отличие от CJS, глобальные переменные `require`, `require.resolve`, `__filename` и `__dirname` недоступны
и должны быть заменены на `import()` и `import.meta.filename`.

::code-group

```js [До]
import { join } from 'path'

const newDir = join(__dirname, 'new-dir')
```

```js [После]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```

::

::code-group

```js [До]
const someFile = require.resolve('./lib/foo.js')
```

```js [После]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```

::

### Лучшие практики

- Предпочитайте именованные экспорты вместо экспорта по умолчанию. Это помогает уменьшить конфликты с CJS. (см. раздел [Экспорты по умолчанию](#default-exports))

- Избегайте зависимости от встроенных модулей Node.js и зависимостей только для CommonJS или Node.js, насколько это возможно, чтобы сделать вашу библиотеку пригодной для использования в браузерах и Edge Workers без необходимости в полифиллах Nitro.

- Используйте новое поле `exports` с условными экспортами. ([подробнее](https://nodejs.org/api/packages.html#conditional-exports)).

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```