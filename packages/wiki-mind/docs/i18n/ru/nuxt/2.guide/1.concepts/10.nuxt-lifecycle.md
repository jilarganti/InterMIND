---
title: "Жизненный цикл Nuxt"
description: "Понимание жизненного цикла приложений Nuxt поможет вам получить более глубокое представление о том, как работает фреймворк, особенно для серверного и клиентского рендеринга."
---

Цель этой главы — предоставить общий обзор различных частей фреймворка, порядка их выполнения и того, как они работают вместе.

## Сервер

На сервере выполняются следующие шаги для каждого первоначального запроса к вашему приложению:

### Шаг 1: Настройка Nitro Server и плагинов Nitro (однократно)

Nuxt работает на базе [Nitro](https://nitro.build/), современного серверного движка.

Когда Nitro запускается, он инициализирует и выполняет плагины из директории `/server/plugins`. Эти плагины могут:
- Перехватывать и обрабатывать ошибки на уровне всего приложения.
- Регистрировать хуки, которые выполняются при завершении работы Nitro.
- Регистрировать хуки для событий жизненного цикла запроса, таких как изменение ответов.

::callout{icon="i-lucide-lightbulb"}
Плагины Nitro выполняются только один раз при запуске сервера. В serverless-среде сервер загружается при каждом входящем запросе, и плагины Nitro тоже. Однако они не ожидаются.
::

:read-more{to="/docs/guide/directory-structure/server#server-plugins"}

### Шаг 2: Middleware сервера Nitro

После инициализации сервера Nitro middleware из `server/middleware/` выполняется для каждого запроса. Middleware может использоваться для таких задач, как аутентификация, логирование или преобразование запросов.

::warning
Возврат значения из middleware завершит запрос и отправит возвращенное значение в качестве ответа. Такого поведения обычно следует избегать для обеспечения правильной обработки запросов!
::

:read-more{to="/docs/guide/directory-structure/server#server-middleware"}

### Шаг 3: Инициализация Nuxt и выполнение плагинов приложения Nuxt

Сначала создаются экземпляры Vue и Nuxt. После этого Nuxt выполняет свои серверные плагины. Это включает:
- Встроенные плагины, такие как Vue Router и `unhead`.
- Пользовательские плагины, расположенные в директории `plugins/`, включая те, что без суффикса (например, `myPlugin.ts`) и те, что с суффиксом `.server` (например, `myServerPlugin.server.ts`).

Плагины выполняются в определенном порядке и могут иметь зависимости друг от друга. Для получения более подробной информации, включая порядок выполнения и параллелизм, обратитесь к [документации по плагинам](/docs/guide/directory-structure/plugins).

::callout{icon="i-lucide-lightbulb"}
После этого шага Nuxt вызывает хук [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime), который может использоваться для выполнения дополнительной логики.
::

:read-more{to="/docs/guide/directory-structure/plugins"}

### Шаг 4: Валидация маршрута

После инициализации плагинов и перед выполнением middleware Nuxt вызывает метод `validate`, если он определен в функции `definePageMeta`. Метод `validate`, который может быть синхронным или асинхронным, часто используется для валидации динамических параметров маршрута.

- Функция `validate` должна возвращать `true`, если параметры валидны.
- Если валидация не пройдена, она должна возвращать `false` или объект, содержащий `statusCode` и/или `statusMessage`, чтобы завершить запрос.

Для получения дополнительной информации см. [документацию по валидации маршрутов](/docs/getting-started/routing#route-validation).

:read-more{to="/docs/getting-started/routing#route-validation"}

### Шаг 5: Выполнение middleware приложения Nuxt

Middleware позволяет выполнять код перед переходом к определенному маршруту. Часто используется для таких задач, как аутентификация, перенаправление или логирование.

В Nuxt существует три типа middleware:
- **Глобальный middleware маршрутов**
- **Именованный middleware маршрутов**
- **Анонимный (или встроенный) middleware маршрутов**

Nuxt выполняет все глобальные middleware при первоначальной загрузке страницы (как на сервере, так и на клиенте), а затем снова перед любой клиентской навигацией. Именованные и анонимные middleware выполняются только на маршрутах, указанных в свойстве middleware метаданных страницы (маршрута), определенных в соответствующих компонентах страницы.

Для получения подробной информации о каждом типе и примеров см. [документацию по middleware](/docs/guide/directory-structure/middleware).

Любое перенаправление на сервере приведет к отправке заголовка `Location:` в браузер; браузер затем сделает новый запрос к этому новому местоположению. Все состояние приложения будет сброшено, когда это произойдет, если только оно не сохранено в cookie.

:read-more{to="/docs/guide/directory-structure/middleware"}

### Шаг 6: Рендеринг страницы и компонентов

Nuxt рендерит страницу и ее компоненты и получает любые необходимые данные с помощью `useFetch` и `useAsyncData` на этом шаге. Поскольку нет динамических обновлений и не происходит операций с DOM на сервере, хуки жизненного цикла Vue, такие как `onBeforeMount`, `onMounted` и последующие хуки, **НЕ** выполняются во время SSR.

По умолчанию Vue приостанавливает отслеживание зависимостей во время SSR для лучшей производительности.

::callout{icon="i-lucide-lightbulb"}
На серверной стороне нет реактивности, потому что Vue SSR рендерит приложение сверху вниз как статический HTML, что делает невозможным возврат назад и изменение контента, который уже был отрендерен.
::

::important
Вам следует избегать кода, который производит побочные эффекты, требующие очистки в корневой области `<script setup>`. Примером таких побочных эффектов является установка таймеров с `setInterval`. В коде только для клиентской стороны мы можем установить таймер, а затем удалить его в `onBeforeUnmount` или `onUnmounted`. Однако, поскольку хуки размонтирования никогда не будут вызваны во время SSR, таймеры останутся навсегда. Чтобы избежать этого, переместите код с побочными эффектами в `onMounted`.
::

::tip{icon="i-lucide-video" to="https://youtu.be/dZSNW07sO-A" target="_blank"}
Посмотрите видео от Daniel Roe, объясняющее серверный рендеринг и глобальное состояние.
::

### Шаг 7: Генерация HTML-вывода

После получения всех необходимых данных и рендеринга компонентов Nuxt объединяет отрендеренные компоненты с настройками из `unhead` для генерации полного HTML-документа. Этот HTML вместе с связанными данными затем отправляется обратно клиенту для завершения процесса SSR.

::callout{icon="i-lucide-lightbulb"}
После рендеринга Vue-приложения в HTML Nuxt вызывает хук [`app:rendered`](/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
Перед финализацией и отправкой HTML Nitro вызовет хук [`render:html`](/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side). Этот хук позволяет вам манипулировать сгенерированным HTML, например, внедрять дополнительные скрипты или изменять мета-теги.
::

## Клиент (браузер)

Эта часть жизненного цикла полностью выполняется в браузере, независимо от того, какой режим Nuxt вы выбрали.

### Шаг 1: Инициализация Nuxt и выполнение плагинов приложения Nuxt

Этот шаг аналогичен выполнению на стороне сервера и включает как встроенные, так и пользовательские плагины.

Пользовательские плагины в директории `plugins/`, такие как плагины без суффикса (например, `myPlugin.ts`) и с суффиксом `.client` (например, `myClientPlugin.client.ts`), выполняются на стороне клиента.

::callout{icon="i-lucide-lightbulb"}
После этого шага Nuxt вызывает хук [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime), который можно использовать для выполнения дополнительной логики.
::

:read-more{to="/docs/guide/directory-structure/plugins"}

### Шаг 2: Валидация маршрута

Этот шаг аналогичен выполнению на стороне сервера и включает метод `validate`, если он определен в функции `definePageMeta`.

### Шаг 3: Выполнение middleware приложения Nuxt

Middleware Nuxt работает как на сервере, так и на клиенте. Если вы хотите, чтобы определенный код выполнялся в конкретных средах, рассмотрите возможность разделения с использованием `import.meta.client` для клиента и `import.meta.server` для сервера.

:read-more{to="/docs/guide/directory-structure/middleware#when-middleware-runs"}

### Шаг 4: Монтирование Vue-приложения и гидратация

Вызов `app.mount('#__nuxt')` монтирует Vue-приложение в DOM. Если приложение использует режим SSR или SSG, Vue выполняет шаг гидратации, чтобы сделать клиентское приложение интерактивным. Во время гидратации Vue воссоздает приложение (исключая [Server Components](/docs/guide/directory-structure/components#server-components)), сопоставляет каждый компонент с соответствующими узлами DOM и присоединяет обработчики событий DOM.

Для обеспечения правильной гидратации важно поддерживать согласованность между данными на сервере и клиенте. Для API-запросов рекомендуется использовать `useAsyncData`, `useFetch` или другие SSR-совместимые композаблы. Эти методы гарантируют, что данные, полученные на стороне сервера, повторно используются во время гидратации, избегая повторных запросов. Любые новые запросы должны запускаться только после гидратации, предотвращая ошибки гидратации.

::callout{icon="i-lucide-lightbulb"}
Перед монтированием Vue-приложения Nuxt вызывает хук [`app:beforeMount`](/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
После монтирования Vue-приложения Nuxt вызывает хук [`app:mounted`](/docs/api/advanced/hooks#app-hooks-runtime).
::

### Шаг 5: Жизненный цикл Vue

В отличие от сервера, браузер выполняет полный [жизненный цикл Vue](https://vuejs.org/guide/essentials/lifecycle).