---
title: "Режимы рендеринга"
description: "Изучите различные режимы рендеринга, доступные в Nuxt."
---

Nuxt поддерживает различные режимы рендеринга: [универсальный рендеринг](#universal-rendering), [клиентский рендеринг](#client-side-rendering), а также предлагает [гибридный рендеринг](#hybrid-rendering) и возможность рендеринга вашего приложения на [CDN Edge серверах](#edge-side-rendering).

И браузер, и сервер могут интерпретировать JavaScript код для преобразования Vue.js компонентов в HTML элементы. Этот шаг называется **рендерингом**. Nuxt поддерживает как **универсальный**, так и **клиентский** рендеринг. Оба подхода имеют преимущества и недостатки, которые мы рассмотрим.

По умолчанию Nuxt использует **универсальный рендеринг** для обеспечения лучшего пользовательского опыта, производительности и оптимизации индексации поисковыми системами, но вы можете переключить режимы рендеринга [одной строкой конфигурации](/docs/api/nuxt-config#ssr).

## Универсальный рендеринг

Этот шаг похож на традиционный **серверный рендеринг**, выполняемый PHP или Ruby приложениями. Когда браузер запрашивает URL с включенным универсальным рендерингом, Nuxt выполняет JavaScript (Vue.js) код в серверной среде и возвращает полностью отрендеренную HTML страницу в браузер. Nuxt также может вернуть полностью отрендеренную HTML страницу из кэша, если страница была сгенерирована заранее. Пользователи немедленно получают весь начальный контент приложения, в отличие от клиентского рендеринга.

После того как HTML документ был загружен, браузер интерпретирует его и Vue.js берет контроль над документом. Тот же JavaScript код, который когда-то выполнялся на сервере, теперь выполняется на клиенте (в браузере) **снова** в фоновом режиме, обеспечивая интерактивность (отсюда **Универсальный рендеринг**) путем привязки своих обработчиков к HTML. Это называется **Гидратация**. Когда гидратация завершена, страница может пользоваться такими преимуществами, как динамические интерфейсы и переходы между страницами.

Универсальный рендеринг позволяет Nuxt приложению обеспечивать быструю загрузку страниц, сохраняя при этом преимущества клиентского рендеринга. Более того, поскольку контент уже присутствует в HTML документе, поисковые роботы могут индексировать его без дополнительных затрат.

![Пользователи могут получить доступ к статическому контенту при загрузке HTML документа. Гидратация затем обеспечивает интерактивность страницы](/assets/docs/concepts/rendering/ssr.svg)

**Что рендерится на сервере, а что на клиенте?**

Нормально задаваться вопросом, какие части Vue файла выполняются на сервере и/или клиенте в режиме универсального рендеринга.

```vue [app.vue]
<script setup lang="ts">
const counter = ref(0); // выполняется в серверной и клиентской средах

const handleClick = () => {
  counter.value++; // выполняется только в клиентской среде
};
</script>

<template>
  <div>
    <p>Счетчик: {{ counter }}</p>
    <button @click="handleClick">Увеличить</button>
  </div>
</template>
```

При первом запросе `counter` ref инициализируется на сервере, поскольку он рендерится внутри тега `<p>`. Содержимое `handleClick` здесь никогда не выполняется. Во время гидратации в браузере `counter` ref переинициализируется. `handleClick` наконец привязывается к кнопке; Поэтому разумно сделать вывод, что тело `handleClick` всегда будет выполняться в браузерной среде.

[Middlewares](/docs/guide/directory-structure/middleware) и [pages](/docs/guide/directory-structure/pages) выполняются на сервере и на клиенте во время гидратации. [Plugins](/docs/guide/directory-structure/plugins) могут рендериться на сервере или клиенте, или на обоих. [Components](/docs/guide/directory-structure/components) также могут быть принудительно запущены только на клиенте. [Composables](/docs/guide/directory-structure/composables) и [utilities](/docs/guide/directory-structure/utils) рендерятся в зависимости от контекста их использования.

**Преимущества серверного рендеринга:**
- **Производительность**: Пользователи могут получить немедленный доступ к контенту страницы, поскольку браузеры могут отображать статический контент намного быстрее, чем контент, сгенерированный JavaScript. В то же время Nuxt сохраняет интерактивность веб-приложения во время процесса гидратации.
- **Поисковая оптимизация**: Универсальный рендеринг доставляет весь HTML контент страницы в браузер как классическое серверное приложение. Веб-краулеры могут напрямую индексировать контент страницы, что делает универсальный рендеринг отличным выбором для любого контента, который вы хотите быстро проиндексировать.

**Недостатки серверного рендеринга:**
- **Ограничения разработки:** Серверная и браузерная среды не предоставляют одинаковые API, и может быть сложно писать код, который может беспрепятственно работать на обеих сторонах. К счастью, Nuxt предоставляет руководящие принципы и специальные переменные, которые помогают определить, где выполняется фрагмент кода.
- **Стоимость:** Сервер должен работать для рендеринга страниц на лету. Это добавляет ежемесячную стоимость, как любой традиционный сервер. Однако серверные вызовы значительно сокращаются благодаря универсальному рендерингу, когда браузер берет управление на себя при клиентской навигации. Снижение затрат возможно за счет использования [edge-side-rendering](#edge-side-rendering).

Универсальный рендеринг очень универсален и может подойти практически для любого случая использования, и особенно подходит для любых контент-ориентированных веб-сайтов: **блогов, маркетинговых сайтов, портфолио, сайтов электронной коммерции и торговых площадок.**

::tip
Для получения дополнительных примеров написания Vue кода без несоответствия гидратации, смотрите [документацию Vue](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch).
::

::important
При импорте библиотеки, которая зависит от браузерных API и имеет побочные эффекты, убедитесь, что компонент, импортирующий её, вызывается только на клиентской стороне. Сборщики не выполняют tree-shaking импортов модулей, содержащих побочные эффекты.
::

## Рендеринг на стороне клиента

По умолчанию традиционное приложение Vue.js рендерится в браузере (или на **клиенте**). Затем Vue.js генерирует HTML-элементы после того, как браузер загружает и парсит весь JavaScript-код, содержащий инструкции для создания текущего интерфейса.

![Пользователи должны ждать, пока браузер загрузит, распарсит и выполнит JavaScript, прежде чем увидеть содержимое страницы](/assets/docs/concepts/rendering/csr.svg)

**Преимущества рендеринга на стороне клиента:**
- **Скорость разработки**: При работе полностью на стороне клиента нам не нужно беспокоиться о совместимости кода с сервером, например, используя API, доступные только в браузере, такие как объект `window`.
- **Дешевизна:** Запуск сервера добавляет расходы на инфраструктуру, поскольку потребуется запуск на платформе, поддерживающей JavaScript. Мы можем размещать клиентские приложения на любом статическом сервере с HTML, CSS и JavaScript файлами.
- **Автономная работа:** Поскольку код полностью выполняется в браузере, он может хорошо работать даже при отсутствии интернета.

**Недостатки рендеринга на стороне клиента:**
- **Производительность**: Пользователь должен ждать, пока браузер загрузит, распарсит и выполнит JavaScript файлы. В зависимости от сети для части загрузки и устройства пользователя для парсинга и выполнения, это может занять некоторое время и повлиять на пользовательский опыт.
- **Поисковая оптимизация**: Индексация и обновление контента, доставляемого через рендеринг на стороне клиента, занимает больше времени, чем с HTML-документом, отрендеренным на сервере. Это связано с недостатком производительности, который мы обсуждали, поскольку поисковые роботы не будут ждать полного рендеринга интерфейса при первой попытке индексации страницы. Ваш контент будет дольше появляться и обновляться в результатах поиска при чистом рендеринге на стороне клиента.

Рендеринг на стороне клиента - хороший выбор для сильно интерактивных **веб-приложений**, которые не нуждаются в индексации или пользователи которых посещают их часто. Он может использовать кэширование браузера, чтобы пропустить фазу загрузки при последующих посещениях, например, **SaaS, back-office приложения или онлайн-игры**.

Вы можете включить рендеринг только на стороне клиента с Nuxt в вашем `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
Если вы используете `ssr: false`, вам также следует поместить HTML файл в `~/spa-loading-template.html` с некоторым HTML, который вы хотели бы использовать для рендеринга экрана загрузки, который будет отображаться до гидратации вашего приложения.
:read-more{title="SPA Loading Template" to="/docs/api/configuration/nuxt-config#spaloadingtemplate"}
::

:video-accordion{title="Посмотрите видео от Alexander Lichter о создании простого SPA с Nuxt" videoId="7Lr0QTP1Ro8"}

### Развертывание статического приложения с рендерингом на клиенте

Если вы развертываете ваше приложение на [статическом хостинге](/docs/getting-started/deployment#static-hosting) с командами `nuxt generate` или `nuxt build --prerender`, то по умолчанию Nuxt будет рендерить каждую страницу как отдельный статический HTML файл.

::warning
Если вы предварительно рендерите ваше приложение с командами `nuxt generate` или `nuxt build --prerender`, то вы не сможете использовать никакие серверные эндпоинты, поскольку сервер не будет включен в вашу выходную папку. Если вам нужна серверная функциональность, используйте вместо этого `nuxt build`.
::

Если вы используете чисто клиентский рендеринг, то это может быть излишним. Вам может понадобиться только один файл `index.html`, плюс резервные `200.html` и `404.html`, которые вы можете настроить ваш статический веб-хост обслуживать для всех запросов.

Чтобы достичь этого, мы можем изменить способ предварительного рендеринга маршрутов. Просто добавьте это в [ваши хуки](/docs/api/advanced/hooks#nuxt-hooks-build-time) в вашем `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Не генерировать никаких маршрутов (кроме стандартных)
    }
  },
})
```

Это создаст три файла:

- `index.html`
- `200.html`
- `404.html`

Файлы `200.html` и `404.html` могут быть полезны для хостинг-провайдера, которого вы используете.

#### Пропуск генерации клиентских резервных файлов

При предварительном рендеринге приложения с клиентским рендерингом Nuxt по умолчанию генерирует файлы `index.html`, `200.html` и `404.html`. Однако, если вам нужно предотвратить генерацию любого (или всех) из этих файлов в вашей сборке, вы можете использовать хук `'prerender:generate'` из [Nitro](/docs/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate'(route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      }
    }
  }
})
```

## Гибридный рендеринг

Гибридный рендеринг позволяет использовать различные правила кэширования для каждого маршрута с помощью **правил маршрутов** и определяет, как сервер должен отвечать на новый запрос по заданному URL.

Ранее каждый маршрут/страница приложения Nuxt и сервер должны были использовать один и тот же режим рендеринга - универсальный или клиентский. В различных случаях некоторые страницы могут быть сгенерированы во время сборки, в то время как другие должны рендериться на стороне клиента. Например, представьте контентный веб-сайт с административным разделом. Каждая контентная страница должна быть в первую очередь статической и сгенерированной один раз, но административный раздел требует регистрации и ведет себя больше как динамическое приложение.

Nuxt включает поддержку правил маршрутов и гибридного рендеринга. Используя правила маршрутов, вы можете определить правила для группы маршрутов nuxt, изменить режим рендеринга или назначить стратегию кэширования на основе маршрута!

Сервер Nuxt автоматически зарегистрирует соответствующее промежуточное ПО и обернет маршруты обработчиками кэша, используя [слой кэширования Nitro](https://nitro.build/guide/cache).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Главная страница предварительно рендерится во время сборки
    '/': { prerender: true },
    // Страница товаров генерируется по требованию, ревалидируется в фоне, кэшируется до изменения ответа API
    '/products': { swr: true },
    // Страницы товаров генерируются по требованию, ревалидируются в фоне, кэшируются на 1 час (3600 секунд)
    '/products/**': { swr: 3600 },
    // Страница постов блога генерируется по требованию, ревалидируется в фоне, кэшируется на CDN на 1 час (3600 секунд)
    '/blog': { isr: 3600 },
    // Страница поста блога генерируется по требованию один раз до следующего развертывания, кэшируется на CDN
    '/blog/**': { isr: true },
    // Административная панель рендерится только на стороне клиента
    '/admin/**': { ssr: false },
    // Добавляет cors заголовки на API маршруты
    '/api/**': { cors: true },
    // Перенаправляет устаревшие url
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Правила маршрутов

Различные свойства, которые вы можете использовать, следующие:
- `redirect: string`{lang=ts} - Определяет серверные перенаправления.
- `ssr: boolean`{lang=ts} - Отключает серверный рендеринг HTML для разделов вашего приложения и заставляет их рендериться только в браузере с `ssr: false`
- `cors: boolean`{lang=ts} - Автоматически добавляет cors заголовки с `cors: true` - вы можете настроить вывод, переопределив с помощью `headers`
- `headers: object`{lang=ts} - Добавляет специфические заголовки к разделам вашего сайта - например, к вашим ресурсам
- `swr: number | boolean`{lang=ts} - Добавляет заголовки кэша к ответу сервера и кэширует его на сервере или обратном прокси на настраиваемое TTL (время жизни). Пресет `node-server` Nitro способен кэшировать полный ответ. Когда TTL истекает, кэшированный ответ будет отправлен, пока страница будет регенерироваться в фоне. Если используется true, добавляется заголовок `stale-while-revalidate` без MaxAge.
- `isr: number | boolean`{lang=ts} - Поведение такое же, как у `swr`, за исключением того, что мы можем добавить ответ в кэш CDN на платформах, которые это поддерживают (в настоящее время Netlify или Vercel). Если используется `true`, контент сохраняется до следующего развертывания внутри CDN.
- `prerender: boolean`{lang=ts} - Предварительно рендерит маршруты во время сборки и включает их в вашу сборку как статические ресурсы
- `noScripts: boolean`{lang=ts} - Отключает рендеринг скриптов Nuxt и подсказок JS ресурсов для разделов вашего сайта.
- `appMiddleware: string | string[] | Record<string, boolean>`{lang=ts} - Позволяет определить промежуточное ПО, которое должно или не должно выполняться для путей страниц в части Vue приложения вашего приложения (то есть не ваших маршрутов Nitro)

Когда это возможно, правила маршрутов будут автоматически применены к нативным правилам платформы развертывания для оптимальной производительности (в настоящее время поддерживаются Netlify и Vercel).

::important
Обратите внимание, что гибридный рендеринг недоступен при использовании [`nuxt generate`](/docs/api/commands/generate).
::

**Примеры:**

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Пример приложения Nuxt с гибридным рендерингом, развернутого на Vercel.
  ::
::

## Рендеринг на граничных серверах

Рендеринг на граничных серверах (ESR) — это мощная функция, представленная в Nuxt, которая позволяет выполнять рендеринг вашего Nuxt-приложения ближе к пользователям через граничные серверы сети доставки контента (CDN). Используя ESR, вы можете обеспечить улучшенную производительность и сниженную задержку, тем самым предоставляя улучшенный пользовательский опыт.

С ESR процесс рендеринга перемещается на 'край' сети — граничные серверы CDN. Обратите внимание, что ESR — это скорее цель развертывания, чем фактический режим рендеринга.

Когда поступает запрос на страницу, вместо того чтобы идти до исходного сервера, он перехватывается ближайшим граничным сервером. Этот сервер генерирует HTML для страницы и отправляет его обратно пользователю. Этот процесс минимизирует физическое расстояние, которое должны пройти данные, **снижая задержку и ускоряя загрузку страницы**.

Рендеринг на граничных серверах возможен благодаря [Nitro](https://nitro.build/), [серверному движку](/docs/guide/concepts/server-engine), который питает Nuxt. Он предлагает кроссплатформенную поддержку для Node.js, Deno, Cloudflare Workers и других.

Текущие платформы, где вы можете использовать ESR:
- [Cloudflare Pages](https://pages.cloudflare.com) с нулевой конфигурацией, используя git-интеграцию и команду `nuxt build`
- [Vercel Edge Functions](https://vercel.com/features/edge-functions), используя команду `nuxt build` и переменную окружения `NITRO_PRESET=vercel-edge`
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions), используя команду `nuxt build` и переменную окружения `NITRO_PRESET=netlify-edge`

Обратите внимание, что **гибридный рендеринг** может использоваться при применении рендеринга на граничных серверах с правилами маршрутов.

Вы можете изучить примеры с открытым исходным кодом, развернутые на некоторых из упомянутых выше платформ:
::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Приложение для задач с аутентификацией пользователей, SSR и SQLite.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: Atinotes
  to: https://github.com/atinux/atinotes
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Редактируемый веб-сайт с универсальным рендерингом на основе Cloudflare KV.
  ::
::

<!-- TODO: link to templates with ESR category for examples -->