---
title: "Плагины"
description: "Nuxt имеет систему плагинов для использования Vue плагинов и других компонентов при создании вашего Vue приложения."
head.title: "plugins/"
navigation.icon: i-lucide-folder
---

Nuxt автоматически читает файлы в директории `plugins/` и загружает их при создании Vue приложения.

::note
Все плагины внутри автоматически регистрируются, вам не нужно добавлять их в ваш `nuxt.config` отдельно.
::

::note
Вы можете использовать суффикс `.server` или `.client` в имени файла, чтобы загрузить плагин только на стороне сервера или клиента.
::

## Зарегистрированные плагины

Только файлы на верхнем уровне директории (или index файлы внутри любых поддиректорий) будут автоматически зарегистрированы как плагины.

```bash [Структура директории]
-| plugins/
---| foo.ts      // сканируется
---| bar/
-----| baz.ts    // не сканируется
-----| foz.vue   // не сканируется
-----| index.ts  // в настоящее время сканируется, но устарел
```

Только `foo.ts` и `bar/index.ts` будут зарегистрированы.

Чтобы добавить плагины в поддиректориях, вы можете использовать опцию [`plugins`](/docs/api/nuxt-config#plugins-1) в `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  plugins: [
    '~/plugins/bar/baz',
    '~/plugins/bar/foz'
  ]
})
```

## Создание плагинов

Единственный аргумент, передаваемый плагину, это [`nuxtApp`](/docs/api/composables/use-nuxt-app).

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin(nuxtApp => {
  // Делаем что-то с nuxtApp
})
```

### Плагины с объектным синтаксисом

Также возможно определить плагин, используя объектный синтаксис, для более продвинутых случаев использования. Например:

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre', // или 'post'
  async setup (nuxtApp) {
    // это эквивалент обычного функционального плагина
  },
  hooks: {
    // Вы можете напрямую регистрировать хуки времени выполнения Nuxt приложения здесь
    'app:created'() {
      const nuxtApp = useNuxtApp()
      // делаем что-то в хуке
    }
  },
  env: {
    // Установите это значение в `false`, если вы не хотите, чтобы плагин запускался при рендеринге серверных или островных компонентов.
    islands: true
  }
})
```

:video-accordion{title="Посмотрите видео от Alexander Lichter об объектном синтаксисе для плагинов Nuxt" videoId="2aXZyXB1QGQ"}

::note
Если вы используете объектный синтаксис, свойства статически анализируются для создания более оптимизированной сборки. Поэтому вы не должны определять их во время выполнения. :br
Например, установка `enforce: import.meta.server ? 'pre' : 'post'` сведет на нет любую будущую оптимизацию, которую Nuxt сможет выполнить для ваших плагинов.
Nuxt статически предварительно загружает любые слушатели хуков при использовании объектного синтаксиса, позволяя вам определять хуки без необходимости беспокоиться о порядке регистрации плагинов.
::

## Порядок регистрации

Вы можете контролировать порядок регистрации плагинов, добавляя "алфавитную" нумерацию к именам файлов.

```bash [Структура директории]
plugins/
 | - 01.myPlugin.ts
 | - 02.myOtherPlugin.ts
```

В этом примере `02.myOtherPlugin.ts` сможет получить доступ ко всему, что было внедрено `01.myPlugin.ts`.

Это полезно в ситуациях, когда у вас есть плагин, который зависит от другого плагина.

::note
Если вы новичок в "алфавитной" нумерации, помните, что имена файлов сортируются как строки, а не как числовые значения. Например, `10.myPlugin.ts` будет идти перед `2.myOtherPlugin.ts`. Именно поэтому в примере однозначные числа дополняются префиксом `0`.
::

## Стратегия загрузки

### Параллельные плагины

По умолчанию Nuxt загружает плагины последовательно. Вы можете определить плагин как `parallel`, чтобы Nuxt не ждал завершения выполнения плагина перед загрузкой следующего плагина.

```ts twoslash [plugins/my-plugin.ts]
export default defineNuxtPlugin({
  name: 'my-plugin',
  parallel: true,
  async setup (nuxtApp) {
    // следующий плагин будет выполнен немедленно
  }
})
```

### Плагины с зависимостями

Если плагину нужно дождаться другого плагина перед запуском, вы можете добавить имя плагина в массив `dependsOn`.

```ts twoslash [plugins/depending-on-my-plugin.ts]
export default defineNuxtPlugin({
  name: 'depends-on-my-plugin',
  dependsOn: ['my-plugin'],
  async setup (nuxtApp) {
    // этот плагин будет ждать завершения выполнения `my-plugin` перед запуском
  }
})
```

## Использование композаблов

Вы можете использовать [композаблы](/docs/guide/directory-structure/composables), а также [утилиты](/docs/guide/directory-structure/utils) внутри плагинов Nuxt:

```ts [plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const foo = useFoo()
})
```

Однако имейте в виду, что существуют некоторые ограничения и различия:

::important
**Если композабл зависит от другого плагина, зарегистрированного позже, он может не работать.** :br

Плагины вызываются последовательно в порядке очереди и перед всем остальным. Вы можете использовать композабл, который зависит от другого плагина, который еще не был вызван.
::

::important
**Если композабл зависит от жизненного цикла Vue.js, он не будет работать.** :br

Обычно композаблы Vue.js привязаны к текущему экземпляру компонента, в то время как плагины привязаны только к экземпляру [`nuxtApp`](/docs/api/composables/use-nuxt-app).
::

## Предоставление помощников

Если вы хотите предоставить помощника в экземпляре [`NuxtApp`](/docs/api/composables/use-nuxt-app), верните его из плагина под ключом `provide`.

::code-group
```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin(() => {
  return {
    provide: {
      hello: (msg: string) => `Hello ${msg}!`
    }
  }
})
```
```ts twoslash [plugins/hello-object-syntax.ts]
export default defineNuxtPlugin({
  name: 'hello',
  setup () {
    return {
      provide: {
        hello: (msg: string) => `Hello ${msg}!`
      }
    }
  }
})
```
::

Затем вы можете использовать помощника в ваших компонентах:

```vue [components/Hello.vue]
<script setup lang="ts">
// альтернативно, вы также можете использовать его здесь
const { $hello } = useNuxtApp()
</script>

<template>
  <div>
    {{ $hello('world') }}
  </div>
</template>
```

::important
Обратите внимание, что мы настоятельно рекомендуем использовать [`composables`](/docs/guide/directory-structure/composables) вместо предоставления помощников, чтобы избежать загрязнения глобального пространства имен и сохранить небольшой размер основной точки входа в бандл.
::

::warning
**Если ваш плагин предоставляет `ref` или `computed`, он не будет развернут в `<template>` компонента.** :br
Это связано с тем, как Vue работает с refs, которые не являются элементами верхнего уровня для шаблона. Вы можете прочитать больше об этом [в документации Vue](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates).
::

## Плагины типизации

Если вы возвращаете свои помощники из плагина, они будут типизированы автоматически; вы найдете их типизированными для возвращаемого значения `useNuxtApp()` и в ваших шаблонах.

::note
Если вам нужно использовать предоставленный помощник _внутри_ другого плагина, вы можете вызвать [`useNuxtApp()`](/docs/api/composables/use-nuxt-app), чтобы получить типизированную версию. Но в целом этого следует избегать, если только вы не уверены в порядке плагинов.
::

Для продвинутых случаев использования вы можете объявить тип внедренных свойств следующим образом:

```ts [index.d.ts]
declare module '#app' {
  interface NuxtApp {
    $hello (msg: string): string
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    $hello (msg: string): string
  }
}

export {}
```

::note
Если вы используете WebStorm, вам может потребоваться расширить `@vue/runtime-core` до тех пор, пока [эта проблема](https://youtrack.jetbrains.com/issue/WEB-59818/VUE-TypeScript-WS-PS-does-not-correctly-display-type-of-globally-injected-properties) не будет решена.
::

## Плагины Vue

Если вы хотите использовать плагины Vue, такие как [vue-gtag](https://github.com/MatteoGabriele/vue-gtag) для добавления тегов Google Analytics, вы можете использовать плагин Nuxt для этого.

Сначала установите зависимость плагина Vue:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-gtag-next
```
```bash [yarn]
yarn add --dev vue-gtag-next
```
```bash [pnpm]
pnpm add -D vue-gtag-next
```
```bash [bun]
bun add -D vue-gtag-next
```
::

Затем создайте файл плагина:

```ts [plugins/vue-gtag.client.ts]
import VueGtag, { trackRouter } from 'vue-gtag-next'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(VueGtag, {
    property: {
      id: 'GA_MEASUREMENT_ID'
    }
  })
  trackRouter(useRouter())
})
```

## Директивы Vue

Аналогично, вы можете зарегистрировать пользовательскую директиву Vue в плагине.

```ts twoslash [plugins/my-directive.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('focus', {
    mounted (el) {
      el.focus()
    },
    getSSRProps (binding, vnode) {
      // здесь вы можете предоставить специфичные для SSR свойства
      return {}
    }
  })
})
```

::warning
Если вы регистрируете директиву Vue, вы _должны_ зарегистрировать её как на клиентской, так и на серверной стороне, если только вы не используете её при рендеринге только одной стороны. Если директива имеет смысл только на клиентской стороне, вы всегда можете переместить её в `~/plugins/my-directive.client.ts` и предоставить 'заглушку' директивы для сервера в `~/plugins/my-directive.server.ts`.
::

:read-more{icon="i-simple-icons-vuedotjs" title="Пользовательские директивы в документации Vue" to="https://vuejs.org/guide/reusability/custom-directives.html" target="_blank"}