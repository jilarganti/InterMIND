---
title: "server"
head.title: "server/"
description: "Директория server/ используется для регистрации API и серверных обработчиков в вашем приложении."
navigation.icon: i-lucide-folder
---

Nuxt автоматически сканирует файлы внутри этих директорий для регистрации API и серверных обработчиков с поддержкой Hot Module Replacement (HMR).

```bash [Структура директории]
-| server/
---| api/
-----| hello.ts      # /api/hello
---| routes/
-----| bonjour.ts    # /bonjour
---| middleware/
-----| log.ts        # логирование всех запросов
```

Каждый файл должен экспортировать функцию по умолчанию, определенную с помощью `defineEventHandler()` или `eventHandler()` (псевдоним).

Обработчик может напрямую возвращать JSON данные, `Promise`, или использовать `event.node.res.end()` для отправки ответа.

```ts twoslash [server/api/hello.ts]
export default defineEventHandler((event) => {
  return {
    hello: 'world'
  }
})
```

Теперь вы можете универсально вызывать этот API на ваших страницах и в компонентах:

```vue [pages/index.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/hello')
</script>

<template>
  <pre>{{ data }}</pre>
</template>
```

## Серверные маршруты

Файлы внутри `~/server/api` автоматически получают префикс `/api` в своем маршруте.

:video-accordion{title="Посмотрите видео от Vue School о маршрутах API" videoId="761468863" platform="vimeo"}

Чтобы добавить серверные маршруты без префикса `/api`, поместите их в директорию `~/server/routes`.

**Пример:**

```ts [server/routes/hello.ts]
export default defineEventHandler(() => 'Hello World!')
```

В приведенном выше примере маршрут `/hello` будет доступен по адресу <http://localhost:3000/hello>.

::note
Обратите внимание, что в настоящее время серверные маршруты не поддерживают полную функциональность динамических маршрутов, как это делают [страницы](/docs/guide/directory-structure/pages#dynamic-routes).
::

## Серверное промежуточное ПО

Nuxt автоматически прочитает любой файл в директории `~/server/middleware` для создания серверного промежуточного ПО для вашего проекта.

Обработчики промежуточного ПО будут выполняться при каждом запросе перед любым другим серверным маршрутом для добавления или проверки заголовков, логирования запросов или расширения объекта запроса события.

::note
Обработчики промежуточного ПО не должны ничего возвращать (а также закрывать или отвечать на запрос) и должны только проверять или расширять контекст запроса или выбрасывать ошибку.
::

**Примеры:**

```ts [server/middleware/log.ts]
export default defineEventHandler((event) => {
  console.log('Новый запрос: ' + getRequestURL(event))
})
```

```ts [server/middleware/auth.ts]
export default defineEventHandler((event) => {
  event.context.auth = { user: 123 }
})
```

## Серверные плагины

Nuxt автоматически прочитает любые файлы в директории `~/server/plugins` и зарегистрирует их как плагины Nitro. Это позволяет расширить поведение среды выполнения Nitro и подключиться к событиям жизненного цикла.

**Пример:**

```ts [server/plugins/nitroPlugin.ts]
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

:read-more{to="https://nitro.build/guide/plugins" title="Nitro Plugins" target="_blank"}

## Утилиты сервера

Серверные маршруты работают на основе [h3js/h3](https://github.com/h3js/h3), который поставляется с удобным набором помощников.

:read-more{to="https://www.jsdocs.io/package/h3#package-index-functions" title="Доступные помощники H3 Request" target="_blank"}

Вы можете добавить дополнительные помощники самостоятельно в директории `~/server/utils`.

Например, вы можете определить пользовательскую утилиту обработчика, которая оборачивает оригинальный обработчик и выполняет дополнительные операции перед возвратом финального ответа.

**Пример:**

```ts [server/utils/handler.ts]
import type { EventHandler, EventHandlerRequest } from 'h3'

export const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (
  handler: EventHandler<T, D>
): EventHandler<T, D> =>
  defineEventHandler<T>(async event => {
    try {
      // делаем что-то перед обработчиком маршрута
      const response = await handler(event)
      // делаем что-то после обработчика маршрута
      return { response }
    } catch (err) {
      // Обработка ошибок
      return { err }
    }
  })
```

## Типы серверов

::tip
Эта функция доступна начиная с Nuxt >= 3.5
::

## Рецепты

### Параметры маршрута

Серверные маршруты могут использовать динамические параметры в квадратных скобках в имени файла, например `/api/hello/[name].ts`, и получать к ним доступ через `event.context.params`.

```ts [server/api/hello/[name\\].ts]
export default defineEventHandler((event) => {
  const name = getRouterParam(event, 'name')

  return `Привет, ${name}!`
})
```

::tip{to="https://h3.dev/examples/validate-data#validate-params"}
Альтернативно используйте `getValidatedRouterParams` с валидатором схемы, таким как Zod, для безопасности во время выполнения и типизации.
::

Теперь вы можете универсально вызывать этот API по адресу `/api/hello/nuxt` и получить `Привет, nuxt!`.

### Сопоставление HTTP-метода

Имена файлов обработчиков могут иметь суффиксы `.get`, `.post`, `.put`, `.delete`, ... для сопоставления с [HTTP-методом](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) запроса.

```ts [server/api/test.get.ts]
export default defineEventHandler(() => 'Тестовый обработчик get')
```

```ts [server/api/test.post.ts]
export default defineEventHandler(() => 'Тестовый обработчик post')
```

В приведенном выше примере запрос к `/test` с:

- **GET** методом: Возвращает `Тестовый обработчик get`
- **POST** методом: Возвращает `Тестовый обработчик post`
- Любым другим методом: Возвращает ошибку 405

Вы также можете использовать `index.[method].ts` внутри директории для другой структуризации кода, это полезно для создания пространств имен API.

::code-group
```ts [server/api/foo/index.get.ts]
export default defineEventHandler((event) => {
  // обработка GET запросов для эндпоинта `api/foo`
})
```
```ts [server/api/foo/index.post.ts]
export default defineEventHandler((event) => {
  // обработка POST запросов для эндпоинта `api/foo`
})
```
```ts [server/api/foo/bar.get.ts]
export default defineEventHandler((event) => {
  // обработка GET запросов для эндпоинта `api/foo/bar`
})
```
::

### Универсальный маршрут

Универсальные маршруты полезны для обработки резервных маршрутов.

Например, создание файла с именем `~/server/api/foo/[...].ts` зарегистрирует универсальный маршрут для всех запросов, которые не соответствуют ни одному обработчику маршрута, например `/api/foo/bar/baz`.

```ts [server/api/foo/[...\\].ts]
export default defineEventHandler((event) => {
  // event.context.path для получения пути маршрута: '/api/foo/bar/baz'
  // event.context.params._ для получения сегмента маршрута: 'bar/baz'
  return `Обработчик foo по умолчанию`
})
```

Вы можете задать имя для универсального маршрута, используя `~/server/api/foo/[...slug].ts` и получить к нему доступ через `event.context.params.slug`.

```ts [server/api/foo/[...slug\\].ts]
export default defineEventHandler((event) => {
  // event.context.params.slug для получения сегмента маршрута: 'bar/baz'
  return `Обработчик foo по умолчанию`
})
```

### Обработка тела запроса

```ts [server/api/submit.post.ts]
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { body }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils"}
Альтернативно используйте `readValidatedBody` с валидатором схемы, таким как Zod, для безопасности во время выполнения и типизации.
::

Теперь вы можете универсально вызывать этот API, используя:

```vue [app.vue]
<script setup lang="ts">
async function submit() {
  const { body } = await $fetch('/api/submit', {
    method: 'post',
    body: { test: 123 }
  })
}
</script>
```

::note
Мы используем `submit.post.ts` в имени файла только для сопоставления запросов с методом `POST`, который может принимать тело запроса. При использовании `readBody` в GET-запросе, `readBody` выбросит HTTP-ошибку `405 Method Not Allowed`.
::

### Параметры запроса

Пример запроса `/api/query?foo=bar&baz=qux`

```ts [server/api/query.get.ts]
export default defineEventHandler((event) => {
  const query = getQuery(event)

  return { a: query.foo, b: query.baz }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils"}
Альтернативно используйте `getValidatedQuery` с валидатором схемы, таким как Zod, для безопасности во время выполнения и типизации.
::

### Обработка ошибок

Если ошибки не выброшены, будет возвращен код состояния `200 OK`.

Любые неперехваченные ошибки вернут HTTP-ошибку `500 Internal Server Error`.

Чтобы вернуть другие коды ошибок, выбросьте исключение с [`createError`](/docs/api/utils/create-error):

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  const id = parseInt(event.context.params.id) as number

  if (!Number.isInteger(id)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'ID должен быть целым числом',
    })
  }
  return 'Все хорошо'
})
```

### Коды состояния

Чтобы вернуть другие коды состояния, используйте утилиту [`setResponseStatus`](/docs/api/utils/set-response-status).

Например, чтобы вернуть `202 Accepted`

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  setResponseStatus(event, 202)
})
```

### Конфигурация времени выполнения

::code-group
```ts [server/api/foo.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {
    headers: {
      Authorization: `token ${config.githubToken}`
    }
  })

  return repo
})
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    githubToken: ''
  }
})
```
```ini [.env]
NUXT_GITHUB_TOKEN='<my-super-token>'
```
::

::note
Передача `event` в качестве аргумента в `useRuntimeConfig` необязательна, но рекомендуется передавать его для получения конфигурации времени выполнения, переопределенной [переменными окружения](/docs/guide/going-further/runtime-config#environment-variables) во время выполнения для серверных маршрутов.
::

### Куки запроса

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

### Пересылка контекста и заголовков

По умолчанию ни заголовки входящего запроса, ни контекст запроса не пересылаются при выполнении fetch-запросов в серверных маршрутах. Вы можете использовать `event.$fetch` для пересылки контекста запроса и заголовков при выполнении fetch-запросов в серверных маршрутах.

```ts [server/api/forward.ts]
export default defineEventHandler((event) => {
  return event.$fetch('/api/forwarded')
})
```

::note
Заголовки, которые **не предназначены для пересылки**, **не будут включены** в запрос. Эти заголовки включают, например:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

### Ожидание промисов после ответа

При обработке серверных запросов вам может потребоваться выполнить асинхронные задачи, которые не должны блокировать ответ клиенту (например, кеширование и логирование). Вы можете использовать `event.waitUntil` для ожидания промиса в фоновом режиме без задержки ответа.

Метод `event.waitUntil` принимает промис, который будет ожидаться до завершения обработчика, гарантируя выполнение задачи, даже если сервер иначе завершил бы обработчик сразу после отправки ответа. Это интегрируется с провайдерами времени выполнения для использования их нативных возможностей обработки асинхронных операций после отправки ответа.

```ts [server/api/background-task.ts]
const timeConsumingBackgroundTask = async () => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
};

export default eventHandler((event) => {
  // запланировать фоновую задачу без блокировки ответа
  event.waitUntil(timeConsumingBackgroundTask())

  // немедленно отправить ответ клиенту
  return 'готово'
});
```

## Продвинутое использование

### Конфигурация Nitro

Вы можете использовать ключ `nitro` в `nuxt.config` для прямой установки [конфигурации Nitro](https://nitro.build/config).

::warning
Это продвинутая опция. Пользовательская конфигурация может повлиять на продакшн развертывания, поскольку интерфейс конфигурации может изменяться со временем при обновлении Nitro в semver-minor версиях Nuxt.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // https://nitro.build/config
  nitro: {}
})
```

:read-more{to="/docs/guide/concepts/server-engine"}

### Вложенный роутер

```ts [server/api/hello/[...slug\\].ts]
import { createRouter, defineEventHandler, useBase } from 'h3'

const router = createRouter()

router.get('/test', defineEventHandler(() => 'Hello World'))

export default useBase('/api/hello', router.handler)
```

### Отправка потоков

::tip
Это экспериментальная функция и доступна во всех окружениях.
::

```ts [server/api/foo.get.ts]
import fs from 'node:fs'
import { sendStream } from 'h3'

export default defineEventHandler((event) => {
  return sendStream(event, fs.createReadStream('/path/to/file'))
})
```

### Отправка редиректа

```ts [server/api/foo.get.ts]
export default defineEventHandler(async (event) => {
  await sendRedirect(event, '/path/redirect/to', 302)
})
```

### Устаревший обработчик или middleware

```ts [server/api/legacy.ts]
export default fromNodeMiddleware((req, res) => {
  res.end('Legacy handler')
})
```

::important
Поддержка устаревших функций возможна с использованием [h3js/h3](https://github.com/h3js/h3), но рекомендуется избегать устаревших обработчиков насколько это возможно.
::

```ts [server/middleware/legacy.ts]
export default fromNodeMiddleware((req, res, next) => {
  console.log('Legacy middleware')
  next()
})
```

::warning
Никогда не комбинируйте колбэк `next()` с устаревшим middleware, который является `async` или возвращает `Promise`.
::

### Серверное хранилище

Nitro предоставляет кроссплатформенный [слой хранилища](https://nitro.build/guide/storage). Для настройки дополнительных точек монтирования хранилища вы можете использовать `nitro.storage` или [серверные плагины](#server-plugins).

**Пример добавления Redis хранилища:**

Используя `nitro.storage`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    storage: {
      redis: {
        driver: 'redis',
        /* опции redis коннектора */
        port: 6379, // Redis порт
        host: "127.0.0.1", // Redis хост
        username: "", // требует Redis >= 6
        password: "",
        db: 0, // По умолчанию 0
        tls: {} // tls/ssl
      }
    }
  }
})
```

Затем в вашем API обработчике:

```ts [server/api/storage/test.ts]
export default defineEventHandler(async (event) => {
  // Получить все ключи с помощью
  const keys = await useStorage('redis').getKeys()

  // Установить ключ с помощью
  await useStorage('redis').setItem('foo', 'bar')

  // Удалить ключ с помощью
  await useStorage('redis').removeItem('foo')

  return {}
})
```

::read-more{to="https://nitro.build/guide/storage" target="_blank"}
Читайте больше о слое хранилища Nitro.
::

Альтернативно, вы можете создать точку монтирования хранилища, используя серверный плагин и конфигурацию времени выполнения:

::code-group
```ts [server/plugins/storage.ts]
import redisDriver from 'unstorage/drivers/redis'

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Динамически передавать учетные данные из конфигурации времени выполнения или других источников
  const driver = redisDriver({
      base: 'redis',
      host: useRuntimeConfig().redis.host,
      port: useRuntimeConfig().redis.port,
      /* другие опции redis коннектора */
    })

  // Монтировать драйвер
  storage.mount('redis', driver)
})
```

``` ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    redis: { // Значения по умолчанию
      host: '',
      port: 0,
      /* другие опции redis коннектора */
    }
  }
})
```
::