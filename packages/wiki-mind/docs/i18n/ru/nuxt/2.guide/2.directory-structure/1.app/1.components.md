---
title: "components"
head.title: "components/"
description: "Директория components/ предназначена для размещения всех ваших Vue компонентов."
navigation.icon: i-lucide-folder
---

Nuxt автоматически импортирует любые компоненты из этой директории (вместе с компонентами, которые регистрируются любыми модулями, которые вы можете использовать).

```bash [Структура директории]
-| components/
---| AppHeader.vue
---| AppFooter.vue
```

```html [app.vue]
<template>
  <div>
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>
```

## Имена компонентов

Если у вас есть компонент во вложенных директориях, например:

```bash [Структура директорий]
-| components/
---| base/
-----| foo/
-------| Button.vue
```

... тогда имя компонента будет основано на пути его директории и имени файла, при этом дублирующиеся сегменты будут удалены. Поэтому имя компонента будет:

```html
<BaseFooButton />
```

::note
Для ясности мы рекомендуем, чтобы имя файла компонента соответствовало его имени. Так, в примере выше вы могли бы переименовать `Button.vue` в `BaseFooButton.vue`.
::

Если вы хотите автоматически импортировать компоненты только на основе их имени, а не пути, то вам нужно установить опцию `pathPrefix` в `false`, используя расширенную форму объекта конфигурации:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      pathPrefix: false, // [!code ++]
    },
  ],
});
```

Это регистрирует компоненты, используя ту же стратегию, что использовалась в Nuxt 2. Например, `~/components/Some/MyComponent.vue` будет использоваться как `<MyComponent>`, а не `<SomeMyComponent>`.

## Динамические компоненты

Если вы хотите использовать синтаксис Vue `<component :is="someComputedComponent">`{lang=vue}, вам необходимо использовать хелпер `resolveComponent`, предоставляемый Vue, или импортировать компонент напрямую из `#components` и передать его в проп `is`.

Например:

```vue [pages/index.vue]
<script setup lang="ts">
import { SomeComponent } from '#components'

const MyButton = resolveComponent('MyButton')
</script>

<template>
  <component :is="clickable ? MyButton : 'div'" />
  <component :is="SomeComponent" />
</template>
```

::important
Если вы используете `resolveComponent` для обработки динамических компонентов, убедитесь, что вы не вставляете ничего, кроме имени компонента, которое должно быть строковым литералом и не должно быть переменной или содержать переменную. Строка статически анализируется на этапе компиляции.
::

:video-accordion{title="Посмотрите короткое видео Дэниела Роу о resolveComponent()" videoId="4kq8E5IUM2U"}

В качестве альтернативы, хотя это не рекомендуется, вы можете зарегистрировать все ваши компоненты глобально, что создаст асинхронные чанки для всех ваших компонентов и сделает их доступными во всем приложении.

```diff
  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

Вы также можете выборочно регистрировать некоторые компоненты глобально, поместив их в директорию `~/components/global` или используя суффикс `.global.vue` в имени файла. Как отмечено выше, каждый глобальный компонент рендерится в отдельном чанке, поэтому будьте осторожны и не злоупотребляйте этой функцией.

::note
Опция `global` также может быть установлена для каждой директории компонентов отдельно.
::

## Динамические импорты

Для динамического импорта компонента (также известного как ленивая загрузка компонента) всё, что вам нужно сделать, это добавить префикс `Lazy` к имени компонента. Это особенно полезно, если компонент не всегда нужен.

Используя префикс `Lazy`, вы можете отложить загрузку кода компонента до нужного момента, что может быть полезно для оптимизации размера вашего JavaScript-бандла.

```vue [pages/index.vue]
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Горы</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Показать список</button>
  </div>
</template>
```

## Отложенная (или ленивая) гидратация

Ленивые компоненты отлично подходят для контроля размеров чанков в вашем приложении, но они не всегда улучшают производительность во время выполнения, поскольку все еще загружаются активно, если не отрендерены условно. В реальных приложениях некоторые страницы могут включать много контента и много компонентов, и большую часть времени не все из них должны быть интерактивными сразу после загрузки страницы. Активная загрузка всех компонентов может негативно повлиять на производительность.

Для оптимизации вашего приложения вы можете захотеть отложить гидратацию некоторых компонентов до тех пор, пока они не станут видимыми, или пока браузер не завершит более важные задачи.

Nuxt поддерживает это с помощью ленивой (или отложенной) гидратации, позволяя вам контролировать, когда компоненты становятся интерактивными.

### Стратегии гидратации

Nuxt предоставляет ряд встроенных стратегий гидратации. Только одна стратегия может использоваться для каждого ленивого компонента.

::warning
В настоящее время встроенная ленивая гидратация Nuxt работает только в однофайловых компонентах (SFC) и требует определения пропа в шаблоне (а не распространения объекта пропов через `v-bind`). Она также не работает с прямыми импортами из `#components`.
::

#### `hydrate-on-visible`

Гидратирует компонент, когда он становится видимым во вьюпорте.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

::read-more{to="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" title="IntersectionObserver options"}
Узнайте больше о параметрах для `hydrate-on-visible`.
::

::note
Под капотом это использует встроенную стратегию Vue [`hydrateOnVisible`](https://vuejs.org/guide/components/async.html#hydrate-on-visible).
::

#### `hydrate-on-idle`

Гидратирует компонент, когда браузер простаивает. Это подходит, если вам нужно, чтобы компонент загрузился как можно скорее, но не блокировал критический путь рендеринга.

Вы также можете передать число, которое служит максимальным таймаутом.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-idle />
  </div>
</template>
```

::note
Под капотом это использует встроенную стратегию Vue [`hydrateOnIdle`](https://vuejs.org/guide/components/async.html#hydrate-on-idle).
::

#### `hydrate-on-interaction`

Гидратирует компонент после указанного взаимодействия (например, клик, наведение мыши).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

Если вы не передаете событие или список событий, по умолчанию гидратация происходит при `pointerenter`, `click` и `focus`.

::note
Под капотом это использует встроенную стратегию Vue [`hydrateOnInteraction`](https://vuejs.org/guide/components/async.html#hydrate-on-interaction).
::

#### `hydrate-on-media-query`

Гидратирует компонент, когда окно соответствует медиа-запросу.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-media-query="(max-width: 768px)" />
  </div>
</template>
```

::note
Под капотом это использует встроенную стратегию Vue [`hydrateOnMediaQuery`](https://vuejs.org/guide/components/async.html#hydrate-on-media-query).
::

#### `hydrate-after`

Гидратирует компонент после указанной задержки (в миллисекундах).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-after="2000" />
  </div>
</template>
```

#### `hydrate-when`

Гидратирует компонент на основе булевого условия.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-when="isReady" />
  </div>
</template>
<script setup lang="ts">
const isReady = ref(false)
function myFunction() {
  // запускаем пользовательскую стратегию гидратации...
  isReady.value = true
}
</script>
```

#### `hydrate-never`

Никогда не гидратирует компонент.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-never />
  </div>
</template>
```

### Прослушивание событий гидратации

Все компоненты с отложенной гидратацией испускают событие `@hydrated`, когда они гидратированы.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible @hydrated="onHydrate" />
  </div>
</template>

<script setup lang="ts">
function onHydrate() {
  console.log("Компонент был гидратирован!")
}
</script>
```

### Предостережения и лучшие практики

Отложенная гидратация может предложить преимущества в производительности, но важно использовать ее правильно:

1. **Приоритизируйте контент во вьюпорте:** Избегайте отложенной гидратации для критического контента выше сгиба. Она лучше всего подходит для контента, который не нужен немедленно.

2. **Условный рендеринг:** При использовании `v-if="false"` на ленивом компоненте вам может не понадобиться отложенная гидратация. Вы можете просто использовать обычный ленивый компонент.

3. **Общее состояние:** Будьте внимательны к общему состоянию (`v-model`) между несколькими компонентами. Обновление модели в одном компоненте может запустить гидратацию во всех компонентах, привязанных к этой модели.

4. **Используйте каждую стратегию по назначению:** Каждая стратегия оптимизирована для конкретной цели.
    * `hydrate-when` лучше всего подходит для компонентов, которые не всегда нужно гидратировать.
    * `hydrate-after` для компонентов, которые могут подождать определенное количество времени.
    * `hydrate-on-idle` для компонентов, которые могут быть гидратированы, когда браузер простаивает.

5. **Избегайте `hydrate-never` на интерактивных компонентах:** Если компонент требует взаимодействия с пользователем, он не должен быть настроен на то, чтобы никогда не гидратироваться.

## Прямые импорты

Вы также можете явно импортировать компоненты из `#components`, если хотите или вам нужно обойти функциональность автоматического импорта Nuxt.

```vue [pages/index.vue]
<script setup lang="ts">
import { NuxtLink, LazyMountainsList } from '#components'

const show = ref(false)
</script>

<template>
  <div>
    <h1>Горы</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Показать список</button>
    <NuxtLink to="/">Главная</NuxtLink>
  </div>
</template>
```

## Пользовательские директории

По умолчанию сканируется только директория `~/components`. Если вы хотите добавить другие директории или изменить способ сканирования компонентов в подпапке этой директории, вы можете добавить дополнительные директории в конфигурацию:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    // ~/calendar-module/components/event/Update.vue => <EventUpdate />
    { path: '~/calendar-module/components' },

    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />
    { path: '~/user-module/components', pathPrefix: false },

    // ~/components/special-components/Btn.vue => <SpecialBtn />
    { path: '~/components/special-components', prefix: 'Special' },

    // Важно, чтобы это было последним, если у вас есть переопределения, которые вы хотите применить
    // к подкаталогам `~/components`.
    //
    // ~/components/Btn.vue => <Btn />
    // ~/components/base/Btn.vue => <BaseBtn />
    '~/components'
  ]
})
```

::note
Любые вложенные директории должны быть добавлены первыми, поскольку они сканируются по порядку.
::

## npm пакеты

Если вы хотите автоматически импортировать компоненты из npm пакета, вы можете использовать [`addComponent`](/docs/api/kit/components#addcomponent) в [локальном модуле](/docs/guide/directory-structure/modules) для их регистрации.

::code-group

```ts twoslash [~/modules/register-component.ts]
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```

```vue [app.vue]
<template>
  <div>
    <!--  компонент использует указанное нами имя и импортируется автоматически  -->
    <MyAutoImportedComponent />
  </div>
</template>
```

::

## Расширения компонентов

По умолчанию любой файл с расширением, указанным в [ключе extensions файла `nuxt.config.ts`](/docs/api/nuxt-config#extensions), рассматривается как компонент.
Если вам нужно ограничить расширения файлов, которые должны быть зарегистрированы как компоненты, вы можете использовать расширенную форму объявления директории компонентов и её ключ `extensions`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      extensions: ['.vue'], // [!code ++]
    }
  ]
})
```

## Клиентские компоненты

Если компонент предназначен для рендеринга только на стороне клиента, вы можете добавить суффикс `.client` к вашему компоненту.

```bash [Структура директорий]
| components/
--| Comments.client.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- этот компонент будет отрендерен только на стороне клиента -->
    <Comments />
  </div>
</template>
```

::note
Эта функция работает только с автоимпортами Nuxt и импортами `#components`. Явный импорт этих компонентов по их реальным путям не преобразует их в компоненты только для клиента.
::

::important
Компоненты `.client` рендерятся только после монтирования. Для доступа к отрендеренному шаблону с помощью `onMounted()`, добавьте `await nextTick()` в колбэк хука `onMounted()`.
::

::read-more{to="/docs/api/components/client-only"}
Вы также можете достичь аналогичного результата с помощью компонента `<ClientOnly>`.
::

## Серверные компоненты

Серверные компоненты позволяют выполнять серверный рендеринг отдельных компонентов внутри ваших клиентских приложений. Можно использовать серверные компоненты в Nuxt, даже если вы генерируете статический сайт. Это позволяет создавать сложные сайты, которые сочетают динамические компоненты, HTML с серверным рендерингом и даже статические фрагменты разметки.

Серверные компоненты могут использоваться как самостоятельно, так и в паре с [клиентским компонентом](#paired-with-a-client-component).

:video-accordion{title="Посмотрите видео Learn Vue о серверных компонентах Nuxt" videoId="u1yyXe86xJM"}

::tip{icon="i-lucide-newspaper" to="https://roe.dev/blog/nuxt-server-components" target="_blank"}
Прочитайте руководство Дэниела Роу по серверным компонентам Nuxt.
::

### Автономные серверные компоненты

Автономные серверные компоненты всегда будут рендериться на сервере, также известные как компоненты Islands.

Когда их пропсы обновляются, это приведет к сетевому запросу, который обновит отрендеренный HTML на месте.

Серверные компоненты в настоящее время экспериментальны, и для их использования необходимо включить функцию 'component islands' в вашем nuxt.config:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    componentIslands: true
  }
})
```

Теперь вы можете регистрировать серверные компоненты с суффиксом `.server` и использовать их в любом месте вашего приложения автоматически.

```bash [Структура директорий]
-| components/
---| HighlightedMarkdown.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!--
      это будет автоматически отрендерено на сервере, что означает, что ваши библиотеки
      парсинга markdown + подсветки синтаксиса не включены в клиентский бандл.
     -->
    <HighlightedMarkdown markdown="# Заголовок" />
  </div>
</template>
```

Серверные компоненты используют [`<NuxtIsland>`](/docs/api/components/nuxt-island) под капотом, что означает, что пропс `lazy` и слот `#fallback` передаются в него.

::warning
Серверные компоненты (и islands) должны иметь один корневой элемент. (HTML-комментарии также считаются элементами.)
::

::warning
Пропсы передаются в серверные компоненты через параметры URL-запроса и поэтому ограничены возможной длиной URL, поэтому будьте осторожны и не передавайте огромные объемы данных в серверные компоненты через пропсы.
::

::warning
Будьте осторожны при вложении islands внутри других islands, поскольку каждый island добавляет дополнительные накладные расходы.
::

::warning
Большинство функций для серверных компонентов и компонентов island, таких как слоты и клиентские компоненты, доступны только для однофайловых компонентов.
::

#### Клиентские компоненты внутри серверных компонентов

::note
Эта функция требует, чтобы `experimental.componentIslands.selectiveClient` в вашей конфигурации был установлен в true.
::

Вы можете частично гидратировать компонент, установив атрибут `nuxt-client` на компоненте, который вы хотите загрузить на клиентской стороне.

```vue [components/ServerWithClient.vue]
<template>
  <div>
    <HighlightedMarkdown markdown="# Заголовок" />
    <!-- Counter будет загружен и гидратирован на клиентской стороне -->
    <Counter nuxt-client :count="5" />
  </div>
</template>
```

::note
Это работает только внутри серверного компонента. Слоты для клиентских компонентов работают только с `experimental.componentIsland.selectiveClient`, установленным в `'deep'`, и поскольку они рендерятся на серверной стороне, они не интерактивны на клиентской стороне.
::

#### Контекст серверного компонента

При рендеринге серверного или island компонента, `<NuxtIsland>` делает fetch-запрос, который возвращается с `NuxtIslandResponse`. (Это внутренний запрос, если рендерится на сервере, или запрос, который вы можете увидеть во вкладке сети, если он рендерится при клиентской навигации.)

Это означает:

* Новое Vue-приложение будет создано на серверной стороне для создания `NuxtIslandResponse`.
* Новый 'island context' будет создан при рендеринге компонента.
* Вы не можете получить доступ к 'island context' из остальной части вашего приложения, и вы не можете получить доступ к контексту остальной части вашего приложения из island компонента. Другими словами, серверный компонент или island _изолирован_ от остальной части вашего приложения.
* Ваши плагины будут запущены снова при рендеринге island, если только у них не установлено `env: { islands: false }` (что вы можете сделать в плагине с объектным синтаксисом).

Внутри island компонента вы можете получить доступ к его island контексту через `nuxtApp.ssrContext.islandContext`. Обратите внимание, что пока island компоненты все еще помечены как экспериментальные, формат этого контекста может измениться.

::note
Слоты могут быть интерактивными и обернуты в `<div>` с `display: contents;`
::

### В паре с клиентским компонентом

В этом случае компоненты `.server` + `.client` являются двумя 'половинами' компонента и могут использоваться в продвинутых случаях использования для отдельных реализаций компонента на серверной и клиентской стороне.

```bash [Структура директорий]
-| components/
---| Comments.client.vue
---| Comments.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- этот компонент отрендерит Comments.server на сервере, затем Comments.client после монтирования в браузере -->
    <Comments />
  </div>
</template>
```

## Встроенные компоненты Nuxt

Nuxt предоставляет ряд компонентов, включая `<ClientOnly>` и `<DevOnly>`. Вы можете узнать больше о них в документации API.

::read-more{to="/docs/api"}
::

## Авторы библиотек

Создание библиотек Vue-компонентов с автоматическим tree-shaking и регистрацией компонентов очень просто. ✨

Вы можете использовать метод [`addComponentsDir`](/docs/api/kit/components#addcomponentsdir), предоставляемый из `@nuxt/kit`, для регистрации директории ваших компонентов в вашем Nuxt-модуле.

Представьте структуру директорий такую:

```bash [Структура директорий]
-| node_modules/
---| awesome-ui/
-----| components/
-------| Alert.vue
-------| Button.vue
-----| nuxt.ts
-| pages/
---| index.vue
-| nuxt.config.ts
```

Затем в `awesome-ui/nuxt.ts` вы можете использовать хук `addComponentsDir`:

```ts twoslash
import { createResolver, defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const resolver = createResolver(import.meta.url)

    // Добавить директорию ./components в список
    addComponentsDir({
      path: resolver.resolve('./components'),
      prefix: 'awesome',
    })
  },
})
```

Вот и всё! Теперь в вашем проекте вы можете импортировать вашу UI-библиотеку как Nuxt-модуль в файле `nuxt.config`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['awesome-ui/nuxt']
})
```

... и напрямую использовать компоненты модуля (с префиксом `awesome-`) в нашем `pages/index.vue`:

```vue
<template>
  <div>
    Моя <AwesomeButton>UI кнопка</AwesomeButton>!
    <awesome-alert>Вот уведомление!</awesome-alert>
  </div>
</template>
```

Это автоматически импортирует компоненты только при использовании, а также поддерживает HMR при обновлении ваших компонентов в `node_modules/awesome-ui/components/`.

:link-example{to="/docs/examples/features/auto-imports"}