---
title: "middleware"
description: "Nuxt предоставляет middleware для выполнения кода перед переходом к определенному маршруту."
head.title: "middleware/"
navigation.icon: i-lucide-folder
---

Nuxt предоставляет настраиваемый фреймворк **middleware маршрутов**, который вы можете использовать во всем приложении, идеально подходящий для извлечения кода, который вы хотите выполнить перед переходом к определенному маршруту.

Существует три типа middleware маршрутов:

1. Анонимные (или встроенные) middleware маршрутов определяются непосредственно внутри страницы.
2. Именованные middleware маршрутов, размещаются в `middleware/` и автоматически загружаются через асинхронный импорт при использовании на странице.
3. Глобальные middleware маршрутов, размещаются в `middleware/` с суффиксом `.global` и выполняются при каждом изменении маршрута.

Первые два типа middleware маршрутов могут быть определены в [`definePageMeta`](/docs/api/utils/define-page-meta).

::note
Имена middleware нормализуются в kebab-case: `myMiddleware` становится `my-middleware`.
::

::note
Middleware маршрутов выполняются в Vue части вашего Nuxt приложения. Несмотря на похожее название, они полностью отличаются от [server middleware](/docs/guide/directory-structure/server#server-middleware), которые выполняются в серверной части Nitro вашего приложения.
::

:video-accordion{title="Посмотрите видео от Vue School о всех 3 типах middleware" videoId="761471577" platform="vimeo"}

## Использование

Middleware маршрутов — это навигационные охранники, которые получают текущий маршрут и следующий маршрут в качестве аргументов.

```ts twoslash [middleware/my-middleware.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.params.id === '1') {
    return abortNavigation()
  }
  // В реальном приложении вы, вероятно, не будете перенаправлять каждый маршрут на `/`
  // однако важно проверить `to.path` перед перенаправлением, иначе вы
  // можете получить бесконечный цикл перенаправлений
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

Nuxt предоставляет два глобально доступных помощника, которые могут быть возвращены непосредственно из middleware.

1. [`navigateTo`](/docs/api/utils/navigate-to) - Перенаправляет на указанный маршрут
2. [`abortNavigation`](/docs/api/utils/abort-navigation) - Прерывает навигацию с необязательным сообщением об ошибке.

В отличие от [навигационных охранников](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards) из `vue-router`, третий аргумент `next()` не передается, и **перенаправление или отмена маршрута обрабатывается возвратом значения из middleware**.

Возможные возвращаемые значения:

* ничего (простой `return` или отсутствие return вообще) - не блокирует навигацию и перейдет к следующей функции middleware, если таковая имеется, или завершит навигацию по маршруту
* `return navigateTo('/')` - перенаправляет на указанный путь и установит код перенаправления [`302` Found](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302), если перенаправление происходит на стороне сервера
* `return navigateTo('/', { redirectCode: 301 })` - перенаправляет на указанный путь и установит код перенаправления [`301` Moved Permanently](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301), если перенаправление происходит на стороне сервера
* `return abortNavigation()` - останавливает текущую навигацию
* `return abortNavigation(error)` - отклоняет текущую навигацию с ошибкой

:read-more{to="/docs/api/utils/navigate-to"}
:read-more{to="/docs/api/utils/abort-navigation"}

::important
Мы рекомендуем использовать вышеуказанные вспомогательные функции для выполнения перенаправлений или остановки навигации. Другие возможные возвращаемые значения, описанные в [документации vue-router](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards), могут работать, но в будущем могут произойти критические изменения.
::

## Порядок middleware

Middleware выполняется в следующем порядке:

1. Глобальные Middleware
2. Порядок middleware, определенный на странице (если объявлено несколько middleware с синтаксисом массива)

Например, предположим, что у вас есть следующие middleware и компонент:

```bash [директория middleware/]
-| middleware/
---| analytics.global.ts
---| setup.global.ts
---| auth.ts
```

```vue twoslash [pages/profile.vue]
<script setup lang="ts">
definePageMeta({
  middleware: [
    function (to, from) {
      // Пользовательский встроенный middleware
    },
    'auth',
  ],
});
</script>
```

Вы можете ожидать, что middleware будут выполняться в следующем порядке:

1. `analytics.global.ts`
2. `setup.global.ts`
3. Пользовательский встроенный middleware
4. `auth.ts`

### Упорядочивание глобальных middleware

По умолчанию глобальные middleware выполняются в алфавитном порядке на основе имени файла.

Однако могут быть случаи, когда вы хотите определить конкретный порядок. Например, в последнем сценарии `setup.global.ts` может потребоваться запустить перед `analytics.global.ts`. В этом случае мы рекомендуем добавлять к глобальным middleware префикс с 'алфавитной' нумерацией.

```bash [Структура директории]
-| middleware/
---| 01.setup.global.ts
---| 02.analytics.global.ts
---| auth.ts
```

::note
Если вы новичок в 'алфавитной' нумерации, помните, что имена файлов сортируются как строки, а не как числовые значения. Например, `10.new.global.ts` будет идти перед `2.new.global.ts`. Вот почему в примере однозначные числа имеют префикс `0`.
::

## Когда выполняется middleware

Если ваш сайт рендерится на сервере или генерируется, middleware для начальной страницы будет выполняться как при рендеринге страницы, так и затем снова на клиенте. Это может потребоваться, если вашему middleware нужна браузерная среда, например, если у вас есть генерируемый сайт, агрессивное кеширование ответов или вы хотите прочитать значение из локального хранилища.

Однако, если вы хотите избежать такого поведения, вы можете сделать это:

```ts twoslash [middleware/example.ts]
export default defineNuxtRouteMiddleware(to => {
  // пропустить middleware на сервере
  if (import.meta.server) return
  // полностью пропустить middleware на стороне клиента
  if (import.meta.client) return
  // или пропустить middleware только при начальной загрузке клиента
  const nuxtApp = useNuxtApp()
  if (import.meta.client && nuxtApp.isHydrating && nuxtApp.payload.serverRendered) return
})
```

Это справедливо даже если вы выбрасываете ошибку в вашем middleware на сервере и рендерится страница ошибки. Middleware все равно будет выполняться снова в браузере.

::note
Рендеринг страницы ошибки - это полностью отдельная загрузка страницы, что означает, что любой зарегистрированный middleware будет выполняться снова. Вы можете использовать [`useError`](/docs/getting-started/error-handling#useerror) в middleware для проверки, обрабатывается ли ошибка.
::

## Доступ к маршруту в middleware

Всегда используйте параметры `to` и `from` в вашем middleware для доступа к следующему и предыдущему маршрутам. Избегайте использования композабла [`useRoute()`](/docs/api/composables/use-route) в этом контексте.
**В middleware нет концепции "текущего маршрута"**, поскольку middleware может прервать навигацию или перенаправить на другой маршрут. Композабл `useRoute()` всегда будет неточным в этом контексте.

::warning
Иногда вы можете вызвать композабл, который внутренне использует `useRoute()`, что может вызвать это предупреждение, даже если в вашем middleware нет прямого вызова.
Это приводит к **той же проблеме, что и выше**, поэтому вы должны структурировать свои функции так, чтобы они принимали маршрут в качестве аргумента при использовании в middleware.
::

::code-group
```ts twoslash [middleware/access-route.ts]
// @errors: 2304
export default defineNuxtRouteMiddleware(to => {
  // передача маршрута в функцию, чтобы избежать вызова `useRoute()` в middleware
  doSomethingWithRoute(to)
    
  // ❌ это выведет предупреждение и НЕ рекомендуется
  callsRouteInternally()
})
```

```ts twoslash [utils/handle-route.ts]
// предоставление маршрута в качестве аргумента, чтобы его можно было правильно использовать в middleware
export function doSomethingWithRoute(route = useRoute()) {
  // ...
}
```
```ts twoslash [utils/dont-do-this.ts]
// ❌ эта функция не подходит для использования в middleware
export function callsRouteInternally() {
    const route = useRoute()
  // ...
}
```

::

## Динамическое добавление middleware

Возможно добавлять глобальные или именованные middleware маршрутов вручную, используя вспомогательную функцию [`addRouteMiddleware()`](/docs/api/utils/add-route-middleware), например, из плагина.

```ts twoslash
export default defineNuxtPlugin(() => {
  addRouteMiddleware('global-test', () => {
    console.log('это глобальное middleware было добавлено в плагине и будет выполняться при каждом изменении маршрута')
  }, { global: true })

  addRouteMiddleware('named-test', () => {
    console.log('это именованное middleware было добавлено в плагине и переопределит любое существующее middleware с тем же именем')
  })
})
```

## Пример

```bash [Структура директории]
-| middleware/
---| auth.ts
```

В файле вашей страницы вы можете ссылаться на это промежуточное ПО маршрута:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  middleware: ["auth"]
  // или middleware: 'auth'
})
</script>
```

Теперь, прежде чем навигация к этой странице может завершиться, будет выполнено промежуточное ПО маршрута `auth`.

:link-example{to="/docs/examples/routing/middleware"}

## Установка middleware во время сборки

Вместо использования `definePageMeta` на каждой странице, вы можете добавить именованное middleware маршрута в хуке `pages:extend`.

```ts twoslash [nuxt.config.ts]
import type { NuxtPage } from 'nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      function setMiddleware (pages: NuxtPage[]) {
        for (const page of pages) {
          if (/* некоторое условие */ true) {
            page.meta ||= {}
            // Обратите внимание, что это переопределит любое middleware, установленное в `definePageMeta` на странице
            page.meta.middleware = ['named']
          }
          if (page.children) {
            setMiddleware(page.children)
          }
        }
      }
      setMiddleware(pages)
    }
  }
})
```