---
title: "Экспериментальные функции"
description: "Включите экспериментальные функции Nuxt, чтобы открыть новые возможности."
---

Nuxt включает экспериментальные функции, которые вы можете включить в своем файле конфигурации.

Внутренне Nuxt использует `@nuxt/schema` для определения этих экспериментальных функций. Вы можете обратиться к [документации API](/docs/api/configuration/nuxt-config#experimental) или [исходному коду](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/config/experimental.ts) для получения дополнительной информации.

::note
Обратите внимание, что эти функции являются экспериментальными и могут быть удалены или изменены в будущем.
::

## asyncContext

Включает нативный асинхронный контекст для доступа к вложенным composables в Nuxt и в Nitro. Это открывает возможность использования composables внутри асинхронных composables и снижает вероятность получения ошибки `Nuxt instance is unavailable`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    asyncContext: true
  }
})
```

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/pull/20918" target="_blank"}
Смотрите полное объяснение в GitHub pull-request.
::

## asyncEntry

Включает генерацию асинхронной точки входа для Vue-пакета, помогая поддержке федерации модулей.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    asyncEntry: true
  }
})
```

## externalVue

Выносит `vue`, `@vue/*` и `vue-router` во внешние зависимости при сборке.

*Включено по умолчанию.*

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    externalVue: true
  }
})
```

::warning
Эта функция, вероятно, будет удалена в ближайшем будущем.
::

## emitRouteChunkError

Вызывает хук `app:chunkError`, когда возникает ошибка загрузки vite/webpack чанков. Поведение по умолчанию заключается в перезагрузке нового маршрута при навигации к новому маршруту, когда чанк не удается загрузить.

Если вы установите это значение в `'automatic-immediate'`, Nuxt немедленно перезагрузит текущий маршрут, вместо ожидания навигации. Это полезно для ошибок чанков, которые не вызваны навигацией, например, когда ваше Nuxt приложение не может загрузить [ленивый компонент](/docs/guide/directory-structure/components#dynamic-imports). Потенциальным недостатком такого поведения являются нежелательные перезагрузки, например, когда вашему приложению не нужен чанк, который вызвал ошибку.

Вы можете отключить автоматическую обработку, установив это значение в `false`, или обрабатывать ошибки чанков вручную, установив значение `manual`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    emitRouteChunkError: 'automatic' // или 'automatic-immediate', 'manual' или false
  }
})
```

## restoreState

Позволяет восстановить состояние Nuxt приложения из `sessionStorage` при перезагрузке страницы после ошибки чанка или ручного вызова [`reloadNuxtApp()`](/docs/api/utils/reload-nuxt-app).

Чтобы избежать ошибок гидратации, это будет применено только после монтирования Vue приложения, что означает возможное мерцание при первоначальной загрузке.

::important
Тщательно обдумайте перед включением этой функции, так как она может вызвать неожиданное поведение,
и рассмотрите возможность предоставления явных ключей для [`useState`](/docs/api/composables/use-state), поскольку автоматически сгенерированные ключи могут не совпадать между сборками.
::

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    restoreState: true
  }
})
```

## inlineRouteRules

Определите правила маршрутизации на уровне страницы, используя [`defineRouteRules`](/docs/api/utils/define-route-rules).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    inlineRouteRules: true
  }
})
```

Соответствующие правила маршрутизации будут созданы на основе `path` страницы.

::read-more{to="/docs/api/utils/define-route-rules" icon="i-lucide-square-function"}
Подробнее об утилите `defineRouteRules`.
::

:read-more{to="/docs/guide/concepts/rendering#hybrid-rendering" icon="i-lucide-medal"}

## renderJsonPayloads

Позволяет рендеринг JSON-полезных нагрузок с поддержкой восстановления сложных типов.

*Включено по умолчанию.*

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    renderJsonPayloads: true
  }
})
```

## noVueServer

Отключает конечную точку серверного рендерера Vue в Nitro.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    noVueServer: true
  }
})
```

## payloadExtraction

Включает извлечение полезных нагрузок страниц, сгенерированных с помощью `nuxt generate`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    payloadExtraction: true
  }
})
```

## clientFallback

Включает экспериментальный компонент [`<NuxtClientFallback>`](/docs/api/components/nuxt-client-fallback) для рендеринга контента на клиенте в случае ошибки в SSR.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    clientFallback: true
  }
})
```

## crossOriginPrefetch

Включает кросс-доменную предзагрузку с использованием Speculation Rules API.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true
  }
})
```

::read-more{icon="i-simple-icons-w3c" to="https://wicg.github.io/nav-speculation/prefetch.html" target="_blank"}
Узнайте больше о **Speculation Rules API**.
::

## viewTransition

Включает интеграцию View Transition API с клиентским роутером.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    viewTransition: true
  }
})
```

:link-example{to="https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue" target="_blank"}

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API" target="_blank"}
Узнайте больше о **View Transition API**.
::

## writeEarlyHints

Включает запись ранних подсказок при использовании node сервера.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    writeEarlyHints: true
  }
})
```

## componentIslands

Включает экспериментальную поддержку островов компонентов с [`<NuxtIsland>`](/docs/api/components/nuxt-island) и файлами `.island.vue`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    componentIslands: true // false или 'local+remote'
  }
})
```

:read-more{to="/docs/guide/directory-structure/components#server-components"}

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/issues/19772" target="_blank"}
Вы можете следить за дорожной картой серверных компонентов на GitHub.
::

## localLayerAliases

Разрешение алиасов `~`, `~~`, `@` и `@@`, расположенных внутри слоев, относительно их исходных директорий и корневых каталогов слоев.

*Включено по умолчанию.*

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    localLayerAliases: true
  }
})
```

## typedPages

Включите новый экспериментальный типизированный роутер, используя [`unplugin-vue-router`](https://github.com/posva/unplugin-vue-router).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    typedPages: true
  }
})
```

Из коробки это включит типизированное использование [`navigateTo`](/docs/api/utils/navigate-to), [`<NuxtLink>`](/docs/api/components/nuxt-link), [`router.push()`](/docs/api/composables/use-router) и многого другого.

Вы даже можете получить типизированные параметры внутри страницы, используя `const route = useRoute('route-name')`.

::important
Если вы используете `pnpm` без `shamefully-hoist=true`, вам потребуется установить `unplugin-vue-router` как devDependency, чтобы эта функция работала.
::

:video-accordion{title="Посмотрите видео от Daniel Roe, объясняющее типобезопасную маршрутизацию в Nuxt" videoId="SXk-L19gTZk"}

## watcher

Установите альтернативный наблюдатель, который будет использоваться в качестве службы наблюдения для Nuxt.

Nuxt по умолчанию использует `chokidar-granular`, который игнорирует директории верхнего уровня
(такие как `node_modules` и `.git`), исключенные из наблюдения.

Вместо этого вы можете установить `parcel` для использования `@parcel/watcher`, что может улучшить
производительность в больших проектах или на платформах Windows.

Вы также можете установить `chokidar` для наблюдения за всеми файлами в вашей исходной директории.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    watcher: 'chokidar-granular' // 'chokidar' или 'parcel' также являются опциями
  }
})
```

## sharedPrerenderData

Nuxt автоматически делится данными *payload* между страницами, которые предварительно рендерятся. Это может привести к значительному улучшению производительности при предварительном рендеринге сайтов, которые используют `useAsyncData` или `useFetch` и получают одинаковые данные на разных страницах.

При необходимости вы можете отключить эту функцию.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

:video-accordion{title="Посмотрите видео от Alexander Lichter об экспериментальной функции sharedPrerenderData" videoId="1jUupYHVvrU"}

Особенно важно при включении этой функции убедиться, что любой уникальный ключ ваших данных
всегда разрешается к одним и тем же данным. Например, если вы используете `useAsyncData` для получения
данных, связанных с конкретной страницей, вы должны предоставить ключ, который уникально соответствует этим данным. (`useFetch`
должен делать это автоматически для вас.)

```ts
// Это было бы небезопасно на динамической странице (например, `[slug].vue`), потому что slug маршрута влияет
// на получаемые данные, но Nuxt не может этого знать, поскольку это не отражено в ключе.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Вместо этого вы должны использовать ключ, который уникально идентифицирует получаемые данные.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

## clientNodeCompat

С этой функцией Nuxt автоматически добавит полифиллы для импортов Node.js в клиентской сборке, используя [`unenv`](https://github.com/unjs/unenv).

::note
Чтобы глобальные переменные, такие как `Buffer`, работали в браузере, вам нужно вручную внедрить их.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer = globalThis.Buffer || Buffer
```
::

## scanPageMeta

Nuxt предоставляет некоторые метаданные маршрута, определенные в `definePageMeta` во время сборки для модулей (в частности `alias`, `name`, `path`, `redirect`, `props` и `middleware`).

Это работает только со статическими значениями или строками/массивами, а не с переменными или условным присваиванием. См. [исходную проблему](https://github.com/nuxt/nuxt/issues/24770) для получения дополнительной информации и контекста.

По умолчанию метаданные страницы сканируются только после того, как все маршруты были зарегистрированы в `pages:extend`. Затем будет вызван другой хук `pages:resolved`.

Вы можете отключить эту функцию, если она вызывает проблемы в вашем проекте.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: false
  }
})
```

## cookieStore

Включает поддержку CookieStore для прослушивания обновлений cookie (если поддерживается браузером) и обновления значений ref `useCookie`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    cookieStore: true
  }
})
```

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/CookieStore" target="_blank"}
Узнайте больше о **CookieStore**.
::

## buildCache

Кэширует артефакты сборки Nuxt на основе хеша конфигурации и исходных файлов.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    buildCache: true
  }
})
```

При включении изменения в следующих файлах вызовут полную пересборку:

```bash [Структура директории]
.nuxtrc
.npmrc
package.json
package-lock.json
yarn.lock
pnpm-lock.yaml
tsconfig.json
bun.lock
bun.lockb
```

Кроме того, любые изменения файлов в `srcDir` вызовут пересборку клиентского/серверного бандла Vue. Nitro всегда будет пересобираться (хотя ведется работа по тому, чтобы позволить Nitro объявлять свои кэшируемые артефакты и их хеши).

::note
Сохраняется максимум 10 архивов кэша.
::

## extraPageMetaExtractionKeys

Макрос `definePageMeta()` — это полезный способ сбора метаданных о страницах во время сборки. Сам Nuxt предоставляет установленный список поддерживаемых ключей, который используется для работы некоторых внутренних функций, таких как перенаправления, псевдонимы страниц и пользовательские пути.

Эта опция позволяет передавать дополнительные ключи для извлечения из метаданных страницы при использовании `scanPageMeta`.

```vue
<script lang="ts" setup>
definePageMeta({
  foo: 'bar'
})
</script>
```

```ts
export default defineNuxtConfig({
  experimental: {
    extraPageMetaExtractionKeys: ['foo'],
  },
  hooks: {
    'pages:resolved' (ctx) {
      // ✅ foo доступен
    },
  },
})
```

Это позволяет модулям получать доступ к дополнительным метаданным из метаданных страницы в контексте сборки. Если вы используете это в модуле, рекомендуется также [дополнить типы `NuxtPage` вашими ключами](/docs/guide/directory-structure/pages#typing-custom-metadata).

## normalizeComponentNames

Nuxt обновляет автоматически сгенерированные имена Vue компонентов, чтобы они соответствовали полному имени компонента, которое вы бы использовали для автоматического импорта компонента.

Если у вас возникают проблемы, вы можете отключить эту функцию.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

По умолчанию, если вы не установили это вручную, Vue назначит имя компонента, которое соответствует имени файла компонента.

```bash [Структура директорий]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

В этом случае имя компонента будет `MyComponent`, с точки зрения Vue. Если вы хотите использовать `<KeepAlive>` с ним или идентифицировать его в Vue DevTools, вам нужно будет использовать этот компонент.

Но для автоматического импорта вам нужно будет использовать `SomeFolderMyComponent`.

Установив `experimental.normalizeComponentNames`, эти два значения совпадают, и Vue сгенерирует имя компонента, которое соответствует паттерну Nuxt для именования компонентов.

## spaLoadingTemplateLocation

При рендеринге страницы только на клиенте (с `ssr: false`), мы опционально отображаем экран загрузки (из `~/spa-loading-template.html`).

Можно установить значение `within`, которое будет отображать его следующим образом:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Альтернативно, вы можете отобразить шаблон рядом с корневым элементом приложения Nuxt, установив значение `body`:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

Это позволяет избежать белой вспышки при гидратации страницы только на клиенте.

## browserDevtoolsTiming

Включает маркеры производительности для хуков Nuxt в инструментах разработчика браузера. Это добавляет маркеры производительности, которые вы можете отслеживать во вкладке Performance браузеров на основе Chromium, что полезно для отладки и оптимизации производительности.

Эта функция включена по умолчанию в режиме разработки. Если вам нужно отключить эту функцию, это возможно сделать:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    browserDevtoolsTiming: false
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/29922" target="_blank"}
См. PR #29922 для деталей реализации.
::

::read-more{icon="i-simple-icons-googlechrome" color="gray" to="https://developer.chrome.com/docs/devtools/performance/extension#tracks" target="_blank"}
Узнайте больше о Chrome DevTools Performance API.
::

## debugModuleMutation

Записывает мутации в `nuxt.options` в контексте модуля, помогая отлаживать изменения конфигурации, вносимые модулями во время фазы инициализации Nuxt.

Эта функция включена по умолчанию, когда включен режим `debug`. Если вам нужно отключить эту функцию, это возможно сделать:

Чтобы включить её явно:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    debugModuleMutation: true
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/30555" target="_blank"}
См. PR #30555 для деталей реализации.
::

## lazyHydration

Это включает стратегии гидратации для компонентов `<Lazy>`, что улучшает производительность за счет отсрочки гидратации компонентов до тех пор, пока они не понадобятся.

Ленивая гидратация включена по умолчанию, но вы можете отключить эту функцию:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    lazyHydration: false
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="/docs/guide/directory-structure/components#delayed-or-lazy-hydration"}
Узнать больше о ленивой гидратации.
::

## templateImportResolution

Управляет тем, как разрешаются импорты в шаблонах Nuxt. По умолчанию Nuxt пытается разрешить импорты в шаблонах относительно модуля, который их добавил.

Эта функция включена по умолчанию, поэтому если вы сталкиваетесь с конфликтами разрешения в определенных средах, вы можете отключить это поведение:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    templateImportResolution: false
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31175" target="_blank"}
См. PR #31175 для деталей реализации.
::

## decorators

Эта опция включает поддержку синтаксиса декораторов во всем вашем Nuxt/Nitro приложении, работающая на основе [esbuild](https://github.com/evanw/esbuild/releases/tag/v0.21.3).

В течение долгого времени TypeScript поддерживал декораторы через `compilerOptions.experimentalDecorators`. Эта реализация появилась до процесса стандартизации TC39. Теперь декораторы являются [предложением Stage 3](https://github.com/tc39/proposal-decorators) и поддерживаются без специальной конфигурации в TS 5.0+ (см. https://github.com/microsoft/TypeScript/pull/52582 и https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#decorators).

Включение `experimental.decorators` активирует поддержку предложения TC39, а **НЕ** предыдущую реализацию TypeScript `compilerOptions.experimentalDecorators`.

::warning
Обратите внимание, что могут быть изменения до того, как это окончательно войдет в стандарт JS.
::

### Использование

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    decorators: true,
  },
})
```

```ts [app.vue]
function something (_method: () => unknown) {
  return () => 'decorated'
}

class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}

const value = new SomeClass().someMethod()
// это вернет 'decorated'
```

## purgeCachedData

Nuxt автоматически очищает кэшированные данные из `useAsyncData` и `nuxtApp.static.data`. Это помогает предотвратить утечки памяти
и обеспечивает загрузку свежих данных при необходимости, но можно отключить эту функцию:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    purgeCachedData: false
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31379" target="_blank"}
См. PR #31379 для деталей реализации.
::

## granularCachedData

Определяет, следует ли вызывать и использовать результат из `getCachedData` при обновлении данных для `useAsyncData` и `useFetch` (будь то через `watch`, `refreshNuxtData()` или ручной вызов `refresh()`).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    granularCachedData: true
  }
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31373" target="_blank"}
См. PR #31373 для деталей реализации.
::

## pendingWhenIdle

Если установлено в `false`, объект `pending`, возвращаемый из `useAsyncData`, `useFetch`, `useLazyAsyncData` и `useLazyFetch`, будет вычисляемым свойством, которое равно `true` только когда `status` также находится в состоянии ожидания.

Это означает, что когда передается `immediate: false`, `pending` будет равно `false` до тех пор, пока не будет выполнен первый запрос.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: false
  }
})
```