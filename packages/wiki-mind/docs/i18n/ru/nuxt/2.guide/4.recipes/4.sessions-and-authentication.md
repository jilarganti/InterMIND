---
title: "Сессии и аутентификация"
description: "Аутентификация является крайне распространенным требованием в веб-приложениях. Этот рецепт покажет вам, как реализовать базовую регистрацию пользователей и аутентификацию в вашем Nuxt приложении."
---

## Введение

В этом рецепте мы настроим аутентификацию в полнофункциональном Nuxt приложении, используя [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils), который предоставляет удобные утилиты для управления данными сессии на стороне клиента и сервера.

Модуль использует защищенные и запечатанные cookies для хранения данных сессии, поэтому вам не нужно настраивать базу данных для хранения данных сессии.

## Установка nuxt-auth-utils

Установите модуль `nuxt-auth-utils` с помощью CLI `nuxt`.

```bash [Terminal]
npx nuxt module add auth-utils
```

::callout
Эта команда установит `nuxt-auth-utils` как зависимость и добавит его в секцию `modules` нашего `nuxt.config.ts`
::

## Ключ шифрования cookie

Поскольку `nuxt-auth-utils` использует запечатанные cookie для хранения данных сессии, cookie сессии шифруются с помощью секретного ключа из переменной окружения `NUXT_SESSION_PASSWORD`.

::note
Если не установлена, эта переменная окружения будет автоматически добавлена в ваш `.env` при запуске в режиме разработки.
::

```ini [.env]
NUXT_SESSION_PASSWORD=случайный-пароль-минимум-32-символа
```

::important
Вам необходимо добавить эту переменную окружения в вашу производственную среду перед развертыванием.
::

## API маршрут для входа в систему

В этом рецепте мы создадим простой API маршрут для входа пользователя в систему на основе статических данных.

Давайте создадим API маршрут `/api/login`, который будет принимать POST запрос с email и паролем в теле запроса.

```ts [server/api/login.post.ts]
import { z } from 'zod'

const bodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
})

export default defineEventHandler(async (event) => {
  const { email, password } = await readValidatedBody(event, bodySchema.parse)

  if (email === 'admin@admin.com' && password === 'iamtheadmin') {
    // устанавливаем пользовательскую сессию в cookie
    // эта серверная утилита автоматически импортируется модулем auth-utils
    await setUserSession(event, {
      user: {
        name: 'John Doe'
      }
    })
    return {}
  }
  throw createError({
    statusCode: 401,
    message: 'Неверные учетные данные'
  })
})
```

::callout
Убедитесь, что установили зависимость `zod` в вашем проекте (`npm i zod`).
::

::tip{to="https://github.com/atinux/nuxt-auth-utils#server-utils"}
Узнайте больше о серверном помощнике `setUserSession`, предоставляемом `nuxt-auth-utils`.
::

## Страница входа

Модуль предоставляет Vue composable для определения, аутентифицирован ли пользователь в нашем приложении:

```vue
<script setup>
const { loggedIn, session, user, clear, fetch } = useUserSession()
</script>
```

Давайте создадим страницу входа с формой для отправки данных входа на наш маршрут `/api/login`.

```vue [pages/login.vue]
<script setup lang="ts">
const { loggedIn, user, fetch: refreshSession } = useUserSession()
const credentials = reactive({
  email: '',
  password: '',
})
async function login() {
  $fetch('/api/login', {
    method: 'POST',
    body: credentials
  })
  .then(async () => {
    // Обновляем сессию на клиентской стороне и перенаправляем на главную страницу
    await refreshSession()
    await navigateTo('/')
  })
  .catch(() => alert('Неверные учетные данные'))
}
</script>

<template>
  <form @submit.prevent="login">
    <input v-model="credentials.email" type="email" placeholder="Email" />
    <input v-model="credentials.password" type="password" placeholder="Пароль" />
    <button type="submit">Войти</button>
  </form>
</template>
```

## Защита API маршрутов

Защита серверных маршрутов является ключевым фактором для обеспечения безопасности ваших данных. Клиентское промежуточное ПО полезно для пользователя, но без серверной защиты ваши данные все еще могут быть доступны. Критически важно защищать любые маршруты с конфиденциальными данными, мы должны возвращать ошибку 401, если пользователь не авторизован на этих маршрутах.

Модуль `auth-utils` предоставляет утилитарную функцию `requireUserSession`, которая помогает убедиться, что пользователи авторизованы и имеют активную сессию.

Давайте создадим пример маршрута `/api/user/stats`, к которому могут получить доступ только аутентифицированные пользователи.

```ts [server/api/user/stats.get.ts]
export default defineEventHandler(async (event) => {
  // убеждаемся, что пользователь авторизован
  // Это вызовет ошибку 401, если запрос не поступает от действительной пользовательской сессии
  const { user } = await requireUserSession(event)

  // TODO: Получить некоторую статистику на основе пользователя

  return {}
});
```

## Защита маршрутов приложения

Наши данные защищены благодаря серверному маршруту, но без дополнительных мер неаутентифицированные пользователи, вероятно, получат странные данные при попытке доступа к странице `/users`. Нам следует создать [клиентское промежуточное ПО](https://nuxt.com/docs/guide/directory-structure/middleware) для защиты маршрута на стороне клиента и перенаправления пользователей на страницу входа.

`nuxt-auth-utils` предоставляет удобный композабл `useUserSession`, который мы будем использовать для проверки авторизации пользователя и перенаправления его в случае отсутствия авторизации.

Мы создадим промежуточное ПО в директории `/middleware`. В отличие от сервера, клиентское промежуточное ПО не применяется автоматически ко всем конечным точкам, и нам нужно указать, где мы хотим его применить.

```typescript [middleware/authenticated.ts]
export default defineNuxtRouteMiddleware(() => {
  const { loggedIn } = useUserSession()

  // перенаправляем пользователя на экран входа, если он не аутентифицирован
  if (!loggedIn.value) {
    return navigateTo('/login')
  }
})
```

## Главная страница

Теперь, когда у нас есть middleware приложения для защиты наших маршрутов, мы можем использовать его на главной странице, которая отображает информацию о нашем аутентифицированном пользователе. Если пользователь не аутентифицирован, он будет перенаправлен на страницу входа.

Мы будем использовать [`definePageMeta`](/docs/api/utils/define-page-meta) для применения middleware к маршруту, который мы хотим защитить.

```vue [pages/index.vue]
<script setup lang="ts">
definePageMeta({
  middleware: ['authenticated'],
})
  
const { user, clear: clearSession } = useUserSession()

async function logout() {
  await clearSession()
  await navigateTo('/login')
}
</script>

<template>
  <div>
    <h1>Добро пожаловать {{ user.name }}</h1>
    <button @click="logout">Выйти</button>
  </div>
</template>
```

Мы также добавили кнопку выхода для очистки сессии и перенаправления пользователя на страницу входа.

## Заключение

Мы успешно настроили базовую аутентификацию пользователей и управление сессиями в нашем Nuxt приложении. Мы также защитили чувствительные маршруты на стороне сервера и клиента, чтобы гарантировать, что только аутентифицированные пользователи могут получить к ним доступ.

В качестве следующих шагов вы можете:
- Добавить аутентификацию, используя [более 20 поддерживаемых OAuth провайдеров](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#supported-oauth-providers)
- Добавить базу данных для хранения пользователей, см. [Nitro SQL Database](https://nitro.build/guide/database) или [NuxtHub SQL Database](https://hub.nuxt.com/docs/features/database)
- Позволить пользователям регистрироваться с email и паролем, используя [хеширование паролей](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#password-hashing)
- Добавить поддержку [WebAuthn / Passkeys](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#webauthn-passkey)

Ознакомьтесь с открытым исходным кодом [репозитория atidone](https://github.com/atinux/atidone) для полного примера Nuxt приложения с OAuth аутентификацией, базой данных и CRUD операциями.