---
navigation.title: "Пользовательский useFetch"
title: "Пользовательский useFetch в Nuxt"
description: "Как создать пользовательский fetcher для вызова внешнего API в Nuxt."
---

При работе с Nuxt вы можете создавать фронтенд и получать данные из внешнего API, и вам может потребоваться установить некоторые параметры по умолчанию для получения данных из вашего API.

Утилитная функция [`$fetch`](/docs/api/utils/dollarfetch) (используемая композаблом [`useFetch`](/docs/api/composables/use-fetch)) намеренно не настраивается глобально. Это важно для того, чтобы поведение получения данных во всем приложении оставалось согласованным, а другие интеграции (например, модули) могли полагаться на поведение основных утилит, таких как `$fetch`.

Однако Nuxt предоставляет способ создания пользовательского fetcher для вашего API (или нескольких fetcher, если у вас есть несколько API для вызова).

## Пользовательский `$fetch`

Давайте создадим пользовательский экземпляр `$fetch` с помощью [плагина Nuxt](/docs/guide/directory-structure/plugins).

::note
`$fetch` — это настроенный экземпляр [ofetch](https://github.com/unjs/ofetch), который поддерживает добавление базового URL вашего Nuxt сервера, а также прямые вызовы функций во время SSR (избегая HTTP обходов).
::

Давайте представим, что:
- Основной API — https://api.nuxt.com
- Мы храним JWT токен в сессии с помощью [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)
- Если API отвечает со статус-кодом `401`, мы перенаправляем пользователя на страницу `/login`

```ts [plugins/api.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const { session } = useUserSession()

  const api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest({ request, options, error }) {
      if (session.value?.token) {
        // обратите внимание, что это зависит от ofetch >= 1.4.0 - возможно, вам нужно обновить ваш lockfile
        options.headers.set('Authorization', `Bearer ${session.value?.token}`)
      }
    },
    async onResponseError({ response }) {
      if (response.status === 401) {
        await nuxtApp.runWithContext(() => navigateTo('/login'))
      }
    }
  })

  // Предоставляем доступ через useNuxtApp().$api
  return {
    provide: {
      api
    }
  }
})
```

С этим плагином Nuxt, `$api` доступен из `useNuxtApp()` для выполнения API вызовов напрямую из Vue компонентов:

```vue [app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
Обертывание с помощью [`useAsyncData`](/docs/api/composables/use-async-data) **избегает двойного получения данных при серверном рендеринге** (сервер и клиент при гидратации).
::

## Пользовательские `useFetch`/`useAsyncData`

Теперь, когда `$api` содержит нужную нам логику, давайте создадим композабл `useAPI` для замены использования `useAsyncData` + `$api`:

```ts [composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app'

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api as typeof $fetch
  })
}
```

Давайте используем новый композабл и получим красивый и чистый компонент:

```vue [app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

Если вы хотите настроить тип любой возвращаемой ошибки, вы также можете это сделать:

```ts
import type { FetchError } from 'ofetch'
import type { UseFetchOptions } from 'nuxt/app'

interface CustomError {
  message: string
  statusCode: number
}

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch<T, FetchError<CustomError>>(url, {
    ...options,
    $fetch: useNuxtApp().$api
  })
}
```

::note
Этот пример демонстрирует, как использовать пользовательский `useFetch`, но та же структура идентична для пользовательского `useAsyncData`.
::

:link-example{to="/docs/examples/advanced/use-custom-fetch-composable"}

:video-accordion{title="Посмотрите видео о пользовательском $fetch и паттерне Repository в Nuxt" videoId="jXH8Tr-exhI"}

::note
В настоящее время мы обсуждаем поиск более чистого способа позволить вам создать пользовательский fetcher, см. https://github.com/nuxt/nuxt/issues/14736.
::