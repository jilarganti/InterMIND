---
navigation.title: "Производительность Nuxt"
title: "Производительность Nuxt"
description: "Лучшие практики для улучшения производительности приложений Nuxt."
---

Nuxt поставляется со встроенными функциями, предназначенными для улучшения производительности вашего приложения и способствующими улучшению [Core Web Vitals](https://web.dev/articles/vitals). Также существует множество основных модулей Nuxt, которые помогают улучшить производительность в конкретных областях. Это руководство описывает лучшие практики для оптимизации производительности вашего Nuxt-приложения.

## Встроенные функции

Nuxt предлагает несколько встроенных функций, которые помогают оптимизировать производительность вашего веб-сайта. Понимание того, как работают эти функции, имеет решающее значение для достижения молниеносной производительности.

### Ссылки

[`<NuxtLink>`](/docs/api/components/nuxt-link) — это готовая замена как для компонента `<RouterLink>` Vue Router, так и для HTML-тега `<a>`. Он интеллектуально определяет, является ли ссылка внутренней или внешней, и соответствующим образом отображает её с доступными оптимизациями (предварительная загрузка, атрибуты по умолчанию и т.д.)

```html
<template>
  <NuxtLink to="/about">О странице</NuxtLink>
</template>

<!-- Что будет отображено с Vue Router и умной предварительной загрузкой -->
<a href="/about">О странице</a>
```

Nuxt автоматически включает умную предварительную загрузку. Это означает, что он определяет, когда ссылка видна (по умолчанию), либо в области просмотра, либо при прокрутке, и предварительно загружает JavaScript для этих страниц, чтобы они были готовы, когда пользователь нажмёт на ссылку.

Вы также можете выбрать предварительную загрузку при взаимодействии:

```ts
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetchOn: 'interaction',
      },
    }
  }
})
```

:read-more{title="NuxtLink" to="/docs/api/components/nuxt-link"}

### Гибридный рендеринг

В более сложных приложениях нам может потребоваться полный контроль над тем, как наше приложение отображается, чтобы поддерживать случаи, когда некоторые страницы могут быть сгенерированы во время сборки, в то время как другие должны отображаться на стороне клиента.

Гибридный рендеринг позволяет использовать различные правила кэширования для каждого маршрута, используя правила маршрутов, и решает, как сервер должен отвечать на новый запрос по заданному URL:

```ts
export default defineNuxtConfig({
  routeRules: {
    '/': {
      prerender: true
    },
    '/products/**': {
      swr: 3600
    },
    '/blog': {
      isr: 3600
    },
    '/admin/**': {
      ssr: false
    },
  }
})
```

Сервер Nuxt автоматически зарегистрирует соответствующее промежуточное ПО и обернёт маршруты обработчиками кэша, используя слой кэширования Nitro.

:read-more{title="Hybrid rendering" to="/docs/guide/concepts/rendering#hybrid-rendering"}

### Ленивая загрузка компонентов

Для динамического импорта компонента (также известного как ленивая загрузка компонента) всё, что вам нужно сделать, это добавить префикс Lazy к имени компонента. Это полезно, если компонент не всегда нужен.

```html
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Горы</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Показать список</button>
  </div>
</template>
```

Используя префикс Lazy, вы можете отложить загрузку кода компонента до нужного момента, что может помочь в оптимизации размера вашего JavaScript-пакета.

:read-more{title="Lazy loading components" to="/docs/guide/directory-structure/components#dynamic-imports"}

### Ленивая гидратация

Не всегда необходимо гидратировать (или делать интерактивными) все компоненты вашего сайта при первоначальной загрузке. Используя ленивую гидратацию, вы можете контролировать, когда компоненты могут загружать свой код, что может улучшить метрику времени до интерактивности для вашего приложения. Nuxt позволяет вам контролировать, когда компоненты становятся интерактивными с помощью ленивой гидратации (добавлено в Nuxt v3.16).

```html
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

Для оптимизации вашего приложения вы можете захотеть отложить гидратацию некоторых компонентов до тех пор, пока они не станут видимыми, или пока браузер не завершит более важные задачи.

:read-more{title="Lazy hydration" to="/docs/guide/directory-structure/components#delayed-or-lazy-hydration"}

### Получение данных

Чтобы избежать получения одних и тех же данных дважды (один раз на сервере и один раз на клиенте), Nuxt предоставляет [`useFetch`](/docs/api/composables/use-fetch) и [`useAsyncData`](/docs/api/composables/use-async-data). Они гарантируют, что если API-вызов выполняется на сервере, данные передаются клиенту в полезной нагрузке вместо повторного получения.

:read-more{title="Data fetching" to="/docs/getting-started/data-fetching"}

## Основные модули Nuxt

Помимо встроенных функций Nuxt, существуют также основные модули, поддерживаемые командой Nuxt, которые помогают еще больше улучшить производительность. Эти модули помогают обрабатывать ресурсы, такие как изображения, пользовательские шрифты или сторонние скрипты.

### Изображения

Неоптимизированные изображения могут оказать значительное негативное влияние на производительность вашего веб-сайта, особенно на показатель [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp).

В Nuxt мы можем использовать модуль [Nuxt Image](https://image.nuxt.com/), который представляет собой готовую к использованию оптимизацию изображений для приложений Nuxt. Он позволяет изменять размер и преобразовывать ваши изображения с помощью встроенного оптимизатора или вашего любимого CDN для изображений.

:video-accordion{title="Посмотрите видео от LearnVue о Nuxt Image" videoId="_UBff2eqGY0"}

[`<NuxtImg>`](/docs/api/components/nuxt-img) является заменой нативного тега `<img>`, которая поставляется со следующими улучшениями:

* Использует встроенный провайдер для оптимизации локальных и удаленных изображений
* Преобразует `src` в оптимизированные URL провайдера с современными форматами, такими как WebP или Avif
* Автоматически изменяет размер изображений на основе `width` и `height`
* Генерирует адаптивные `sizes` при предоставлении опции sizes
* Поддерживает нативную `lazy loading`, а также другие атрибуты `<img>`

Изображения на вашем веб-сайте обычно можно разделить по важности: те, которые нужно доставить первыми при начальной загрузке (т.е. `Largest Contentful Paint`), и те, которые можно загрузить позже или когда это специально необходимо. Для этого мы можем использовать следующие оптимизации:

```html
<template>
  <!-- 🚨 Нужно загрузить как можно скорее -->
  <NuxtImg
    src="/hero-banner.jpg"
    format="webp"
    preload
    loading="eager"
    fetch-priority="high"
    width="200"
    height="100"
  />

  <!-- 🐌 Можно загрузить позже -->
  <NuxtImg
    src="/facebook-logo.jpg"
    format="webp"
    loading="lazy"
    fetch-priority="low"
    width="200"
    height="100"
  />
</template>
```

:read-more{title="Nuxt Image" to="https://image.nuxt.com/usage/nuxt-img"}

### Шрифты

[Nuxt Fonts](https://fonts.nuxt.com/) автоматически оптимизирует ваши шрифты (включая пользовательские шрифты) и устраняет внешние сетевые запросы для улучшения конфиденциальности и производительности.

Он включает встроенное автоматическое самостоятельное размещение для любого файла шрифта, что означает, что вы можете оптимально загружать веб-шрифты с уменьшенным сдвигом макета благодаря базовому пакету [fontaine](https://github.com/unjs/fontaine).

:video-accordion{title="Посмотрите доклад Дэниела Роу об идее, лежащей в основе Nuxt Fonts" videoId="D3F683UViBY"}

Nuxt Fonts обрабатывает весь ваш CSS и автоматически выполняет следующие действия при обнаружении объявления font-family.

1. **Разрешает шрифты** – Ищет файлы шрифтов в public/, затем проверяет веб-провайдеров, таких как Google, Bunny и Fontshare.
2. **Генерирует правила @font-face** – Внедряет CSS-правила для загрузки шрифтов из правильных источников.
3. **Проксирует и кэширует шрифты** – Переписывает URL в `/_fonts`, загружает и кэширует шрифты локально.
4. **Создает метрики резервных шрифтов** – Настраивает локальные системные шрифты для соответствия веб-шрифтам, уменьшая сдвиг макета ([CLS](https://web.dev/articles/cls)).
5. **Включает шрифты в сборку** – Объединяет шрифты с вашим проектом, хэширует имена файлов и устанавливает заголовки долгосрочного кэша.

Он поддерживает множество провайдеров, которые разработаны как подключаемые и расширяемые, поэтому независимо от вашей настройки вы должны иметь возможность использовать существующий провайдер или написать свой собственный.

### Скрипты

Сторонние ресурсы, такие как инструменты аналитики, видео-вставки, карты и интеграции социальных сетей, улучшают функциональность веб-сайта, но могут значительно ухудшить пользовательский опыт и негативно повлиять на показатели [Interaction to Next Paint (INP)](https://web.dev/articles/inp) и Largest Contentful Paint (LCP).

[Nuxt Scripts](https://scripts.nuxt.com/) позволяет загружать сторонние скрипты с лучшей производительностью, конфиденциальностью, безопасностью и DX.

:video-accordion{title="Посмотрите видео от Алекса Лихтера о Nuxt Scripts" videoId="sjMqUUvH9AE"}

Nuxt Scripts предоставляет слой абстракции поверх сторонних скриптов, обеспечивая поддержку SSR и типобезопасность, при этом все еще предоставляя вам полный низкоуровневый контроль над тем, как загружается скрипт.

```ts
const { onLoaded, proxy } = useScriptGoogleAnalytics(
  { 
    id: 'G-1234567',
    scriptOptions: {
      trigger: 'manual',
    },
  },
)
// ставим события в очередь для отправки при загрузке ga
proxy.gtag('config', 'UA-123456789-1')
// или ждем, пока ga загрузится
onLoaded((gtag) => {
  // скрипт загружен
})
```

:read-more{title="Nuxt Scripts" to="https://scripts.nuxt.com/scripts"}

## Инструменты профилирования

Для улучшения производительности нам сначала нужно знать, как её измерить, начиная с измерения производительности во время разработки - в локальной среде, а затем переходя к аудиту приложений, развернутых в продакшене.

### Nuxi Analyze

[Эта команда](/docs/api/commands/analyze) `nuxi` позволяет анализировать продакшн-сборку вашего Nuxt приложения. Она использует `vite-bundle-visualizer` (аналогично `webpack-bundle-analyzer`) для создания визуального представления сборки вашего приложения, что упрощает определение компонентов, занимающих больше всего места.

Когда вы видите большой блок в визуализации, это часто сигнализирует о возможности оптимизации - будь то разделение на более мелкие части, реализация ленивой загрузки или замена на более эффективную альтернативу, особенно для сторонних библиотек.

Большие блоки, содержащие множество элементов, часто можно уменьшить, импортируя только необходимые компоненты, а не целые модули, в то время как большие автономные блоки могут лучше подходить для ленивой загрузки, а не включения в основную сборку.

### Nuxt DevTools

[Nuxt DevTools](https://devtools.nuxt.com/) предоставляет вам понимание и прозрачность вашего Nuxt приложения для выявления проблем с производительностью и беспрепятственного управления конфигурациями приложения.

![Пример Nuxt DevTools](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)

Он поставляется с несколькими функциями, которые мы можем использовать для измерения производительности Nuxt приложений:
1. **Timeline** – Отслеживает время, затраченное на рендеринг, обновление и инициализацию компонентов для выявления узких мест производительности.
2. **Assets** – Отображает размеры файлов (например, изображений) без преобразований.
3. **Render Tree** – Показывает связи между Vue компонентами, скриптами и стилями для оптимизации динамической загрузки.
4. **Inspect** – Перечисляет все файлы, используемые в Vue приложении, с их размером и временем выполнения.

### Chrome DevTools

Chrome DevTools поставляется с двумя полезными вкладками для измерения производительности: `Performance` и `Lighthouse`.

Когда вы открываете панель [Performance](https://developer.chrome.com/docs/devtools/performance/overview), она мгновенно показывает ваши локальные оценки **Largest Contentful Paint (LCP)** и **Cumulative Layout Shift (CLS)** (хорошо, требует улучшения или плохо).

Если вы взаимодействуете со страницей, она также захватывает **Interaction to Next Paint (INP)**, предоставляя вам полное представление о ваших Core Web Vitals на основе вашего устройства и сети.

![Панель производительности Chrome DevTools](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)

[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) проводит аудит производительности, доступности, SEO, прогрессивных веб-приложений и лучших практик. Он запускает тесты на вашей странице и генерирует отчет. Используйте неудачные аудиты как руководство для улучшения вашего сайта.

![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)

Каждый аудит имеет справочный документ, объясняющий, почему аудит важен, а также как его исправить.

### PageSpeed Insights

[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) сообщает о пользовательском опыте страницы как на мобильных, так и на настольных устройствах, и предоставляет предложения о том, как эта страница может быть улучшена.

Он предоставляет как лабораторные, так и полевые данные о странице. Лабораторные данные полезны для отладки проблем, поскольку они собираются в контролируемой среде, в то время как полевые данные полезны для захвата истинного, реального пользовательского опыта.

### Web Page Test

[WebPageTest](https://www.webpagetest.org/) - это инструмент веб-производительности, предоставляющий глубокую диагностическую информацию о том, как страница работает в различных условиях.

Каждый тест может быть запущен из разных мест по всему миру, в реальных браузерах, при любом количестве настраиваемых сетевых условий.

## Распространенные проблемы

При создании более сложных Nuxt приложений вы, вероятно, столкнетесь с некоторыми из проблем, перечисленных ниже. Понимание этих проблем и их устранение поможет вам улучшить производительность вашего веб-сайта.

### Чрезмерное использование плагинов

**Проблема**: Большое количество плагинов может вызвать проблемы с производительностью, особенно если они требуют дорогостоящих вычислений или слишком долго инициализируются. Поскольку плагины выполняются во время фазы гидратации, неэффективные настройки могут блокировать рендеринг и ухудшать пользовательский опыт.

**Решение**: Проверьте ваши плагины и посмотрите, можно ли некоторые из них реализовать как composable или утилитарную функцию.

### Неиспользуемый код / зависимости

**Проблема**: В процессе разработки проекта может возникнуть ситуация, когда появится неиспользуемый код или зависимость. Эта дополнительная функциональность может не использоваться или не быть нужной, при этом увеличивая размер бандла нашего проекта.

**Решение**: Проверьте ваш `package.json` на наличие неиспользуемых зависимостей и проанализируйте ваш код на предмет неиспользуемых утилит/composables/функций.

### Неиспользование советов по производительности Vue

**Проблема**: [Документация Vue](https://vuejs.org/guide/best-practices/performance) содержит несколько улучшений производительности, которые мы также можем использовать в наших Nuxt проектах, но поскольку они являются частью документации Vue, разработчики склонны забывать о них и фокусироваться только на улучшениях, специфичных для Nuxt - в то время как приложение Nuxt все еще остается проектом Vue.

**Решение**: Используйте такие концепции, как `shallowRef`, `v-memo`, `v-once` и т.д. для улучшения производительности.

### Несоблюдение паттернов

**Проблема**: Чем больше людей в настоящее время работает над проектом, тем сложнее будет поддерживать стабильную кодовую базу. Разработчики имеют тенденцию внедрять новые концепции, которые они видели в другом проекте, что может вызвать конфликты и проблемы с производительностью.

**Решение**: Установите правила и паттерны в проекте, такие как [Хорошие практики и паттерны проектирования для Vue Composables](https://dev.to/jacobandrewsky/good-practices-and-design-patterns-for-vue-composables-24lk)

### Попытка загрузить все одновременно

**Проблема**: Когда страница загружается и не получает правильных инструкций о порядке загрузки элементов, это приводит к одновременной загрузке всего - что может быть медленным и привести к плохому пользовательскому опыту.

**Решение**: Используйте такие концепции, как прогрессивное улучшение, где основное содержимое веб-страницы устанавливается первым, а затем более тонкие и технически сложные слои представления и функций добавляются сверху по мере того, как позволяют браузер/интернет-соединение.

## Полезные ресурсы

Чтобы узнать больше о различных техниках улучшения производительности, ознакомьтесь со следующими ресурсами:

1. [Apply instant loading with the PRPL pattern](https://web.dev/articles/apply-instant-loading-with-prpl)
2. [Perceived performance](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/Perceived_performance)
3. [Understanding Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Critical_rendering_path)