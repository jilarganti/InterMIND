---
title: "Получение данных"
description: "Nuxt предоставляет композаблы для обработки получения данных в вашем приложении."
navigation.icon: i-lucide-cable
---

Nuxt поставляется с двумя композаблами и встроенной библиотекой для выполнения получения данных в браузерной или серверной среде: `useFetch`, [`useAsyncData`](/docs/api/composables/use-async-data) и `$fetch`.

Вкратце:

- [`$fetch`](/docs/api/utils/dollarfetch) — это самый простой способ выполнить сетевой запрос.
- [`useFetch`](/docs/api/composables/use-fetch) — это обертка вокруг `$fetch`, которая получает данные только один раз при [универсальном рендеринге](/docs/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/api/composables/use-async-data) похож на `useFetch`, но предлагает более детальный контроль.

И `useFetch`, и `useAsyncData` используют общий набор опций и паттернов, которые мы подробно рассмотрим в последних разделах.

## Необходимость в `useFetch` и `useAsyncData`

Nuxt — это фреймворк, который может выполнять изоморфный (или универсальный) код как в серверной, так и в клиентской среде. Если функция [`$fetch`](/docs/api/utils/dollarfetch) используется для получения данных в setup-функции Vue-компонента, это может привести к двойному получению данных: один раз на сервере (для рендеринга HTML) и еще раз на клиенте (когда HTML гидратируется). Это может вызвать проблемы с гидратацией, увеличить время до интерактивности и привести к непредсказуемому поведению.

Композаблы [`useFetch`](/docs/api/composables/use-fetch) и [`useAsyncData`](/docs/api/composables/use-async-data) решают эту проблему, гарантируя, что если API-вызов выполняется на сервере, данные передаются клиенту в полезной нагрузке.

Полезная нагрузка — это JavaScript-объект, доступный через [`useNuxtApp().payload`](/docs/api/composables/use-nuxt-app#payload). Он используется на клиенте, чтобы избежать повторного получения тех же данных, когда код выполняется в браузере [во время гидратации](/docs/guide/concepts/rendering#universal-rendering).

::tip
Используйте [Nuxt DevTools](https://devtools.nuxt.com) для проверки этих данных во вкладке **Payload**.
::

```vue [app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit() {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // Данные моей формы
    }
  })
}
</script>

<template>
  <div v-if="data == undefined">
    Нет данных
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- теги ввода формы -->
    </form>
  </div>
</template>
```

В приведенном выше примере `useFetch` гарантирует, что запрос будет выполнен на сервере и правильно передан в браузер. `$fetch` не имеет такого механизма и является лучшим вариантом для использования, когда запрос выполняется исключительно из браузера.

### Suspense

Nuxt использует компонент [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) Vue под капотом, чтобы предотвратить навигацию до того, как все асинхронные данные станут доступны для представления. Композаблы для получения данных могут помочь вам использовать эту функцию и применять то, что лучше всего подходит для каждого конкретного вызова.

::note
Вы можете добавить [`<NuxtLoadingIndicator>`](/docs/api/components/nuxt-loading-indicator), чтобы добавить индикатор прогресса между навигацией по страницам.
::

## `$fetch`

Nuxt включает библиотеку [ofetch](https://github.com/unjs/ofetch) и автоматически импортирует её как псевдоним `$fetch` глобально во всём вашем приложении.

```vue twoslash [pages/todos.vue]
<script setup lang="ts">
async function addTodo() {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // Данные моей задачи
    }
  })
}
</script>
```

::warning
Имейте в виду, что использование только `$fetch` не обеспечит [дедупликацию сетевых вызовов и предотвращение навигации](#the-need-for-usefetch-and-useasyncdata). :br
Рекомендуется использовать `$fetch` для клиентских взаимодействий (основанных на событиях) или в сочетании с [`useAsyncData`](#useasyncdata) при получении начальных данных компонента.
::

::read-more{to="/docs/api/utils/dollarfetch"}
Узнайте больше о `$fetch`.
::

### Передача заголовков клиента в API

При вызове `useFetch` на сервере, Nuxt будет использовать [`useRequestFetch`](/docs/api/composables/use-request-fetch) для проксирования заголовков и cookies клиента (за исключением заголовков, которые не предназначены для пересылки, таких как `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo');
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

В качестве альтернативы, пример ниже показывает, как использовать [`useRequestHeaders`](/docs/api/composables/use-request-headers) для доступа и отправки cookies в API из серверного запроса (исходящего от клиента). Используя изоморфный вызов `$fetch`, мы гарантируем, что API endpoint имеет доступ к тому же заголовку `cookie`, который изначально был отправлен браузером пользователя. Это необходимо только если вы не используете `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser() {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
Вы также можете использовать [`useRequestFetch`](/docs/api/composables/use-request-fetch) для автоматического проксирования заголовков в вызове.
::

::caution
Будьте очень осторожны перед проксированием заголовков во внешний API и включайте только те заголовки, которые вам нужны. Не все заголовки безопасны для пересылки и могут привести к нежелательному поведению. Вот список распространённых заголовков, которые НЕ следует проксировать:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

Композабл [`useFetch`](/docs/api/composables/use-fetch) использует `$fetch` под капотом для выполнения SSR-безопасных сетевых вызовов в функции setup.

```vue twoslash [app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Посещения страницы: {{ count }}</p>
</template>
```

Этот композабл является оберткой вокруг композабла [`useAsyncData`](/docs/api/composables/use-async-data) и утилиты `$fetch`.

:video-accordion{title="Посмотрите видео от Alexander Lichter о том, как избежать неправильного использования useFetch" videoId="njsGVmcWviY"}

:read-more{to="/docs/api/composables/use-fetch"}

:link-example{to="/docs/examples/features/data-fetching"}

## `useAsyncData`

Композабл `useAsyncData` отвечает за обертывание асинхронной логики и возврат результата после его разрешения.

::tip
`useFetch(url)` практически эквивалентен `useAsyncData(url, () => event.$fetch(url))`. :br
Это синтаксический сахар для наиболее распространенного случая использования. (Подробнее о `event.fetch` можно узнать в [`useRequestFetch`](/docs/api/composables/use-request-fetch).)
::

:video-accordion{title="Посмотрите видео от Alexander Lichter, чтобы глубже понять разницу между useFetch и useAsyncData" videoId="0X-aOpSGabA"}

Есть случаи, когда использование композабла [`useFetch`](/docs/api/composables/use-fetch) неуместно, например, когда CMS или сторонний сервис предоставляют свой собственный слой запросов. В этом случае вы можете использовать [`useAsyncData`](/docs/api/composables/use-async-data) для обертывания ваших вызовов и при этом сохранить преимущества, предоставляемые композаблом.

```vue [pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// Это также возможно:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
Первый аргумент [`useAsyncData`](/docs/api/composables/use-async-data) — это уникальный ключ, используемый для кеширования ответа второго аргумента, функции запроса. Этот ключ можно игнорировать, передав функцию запроса напрямую, ключ будет сгенерирован автоматически.
:br :br
Поскольку автогенерируемый ключ учитывает только файл и строку, где вызывается `useAsyncData`, рекомендуется всегда создавать собственный ключ, чтобы избежать нежелательного поведения, например, при создании собственного пользовательского композабла, обертывающего `useAsyncData`.
:br :br
Установка ключа может быть полезна для совместного использования одних и тех же данных между компонентами с помощью [`useNuxtData`](/docs/api/composables/use-nuxt-data) или для [обновления конкретных данных](/docs/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

Композабл `useAsyncData` — отличный способ обернуть и дождаться завершения нескольких запросов `$fetch`, а затем обработать результаты.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons'),
    $fetch('/cart/offers')
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` предназначен для получения и кеширования данных, а не для запуска побочных эффектов, таких как вызов действий Pinia, поскольку это может вызвать нежелательное поведение, например, повторные выполнения с нулевыми значениями. Если вам нужно запустить побочные эффекты, используйте утилиту [`callOnce`](/docs/api/utils/call-once).

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// вы не можете делать это
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="/docs/api/composables/use-async-data"}
Подробнее о `useAsyncData`.
::

## Возвращаемые значения

`useFetch` и `useAsyncData` имеют одинаковые возвращаемые значения, перечисленные ниже.

- `data`: результат асинхронной функции, которая передается в качестве параметра.
- `refresh`/`execute`: функция, которая может использоваться для обновления данных, возвращаемых функцией `handler`.
- `clear`: функция, которая может использоваться для установки `data` в `undefined` (или значение `options.default()`, если предоставлено), установки `error` в `undefined`, установки `status` в `idle` и пометки всех текущих ожидающих запросов как отмененных.
- `error`: объект ошибки, если получение данных не удалось.
- `status`: строка, указывающая статус запроса данных (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` и `status` являются Vue refs, доступными через `.value` в `<script setup>`
::

По умолчанию Nuxt ждет завершения `refresh` перед тем, как его можно будет выполнить снова.

::note
Если вы не получили данные на сервере (например, с `server: false`), то данные _не будут_ получены до завершения гидратации. Это означает, что даже если вы используете await `useFetch` на клиентской стороне, `data` останется null внутри `<script setup>`.
::

<translated_markdown>
## Опции

[`useAsyncData`](/docs/api/composables/use-async-data) и [`useFetch`](/docs/api/composables/use-fetch) возвращают один и тот же тип объекта и принимают общий набор опций в качестве последнего аргумента. Они могут помочь вам контролировать поведение композаблов, такое как блокировка навигации, кэширование или выполнение.

### Ленивая загрузка

По умолчанию композаблы для получения данных будут ждать разрешения своей асинхронной функции перед переходом на новую страницу, используя Vue Suspense. Эту функцию можно игнорировать при навигации на стороне клиента с помощью опции `lazy`. В этом случае вам нужно будет вручную обрабатывать состояние загрузки, используя значение `status`.

```vue twoslash [app.vue]
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- вам нужно будет обработать состояние загрузки -->
  <div v-if="status === 'pending'">
    Загрузка ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- сделать что-то -->
    </div>
  </div>
</template>
```

В качестве альтернативы вы можете использовать [`useLazyFetch`](/docs/api/composables/use-lazy-fetch) и `useLazyAsyncData` как удобные методы для выполнения того же самого.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="/docs/api/composables/use-lazy-fetch"}
Узнайте больше о `useLazyFetch`.
::

::read-more{to="/docs/api/composables/use-lazy-async-data"}
Узнайте больше о `useLazyAsyncData`.
::

:video-accordion{title="Посмотрите видео от Vue School о блокирующих и неблокирующих (ленивых) запросах" videoId="1022000555" platform="vimeo"}

### Получение данных только на клиенте

По умолчанию композаблы для получения данных будут выполнять свою асинхронную функцию как в клиентской, так и в серверной среде. Установите опцию `server` в `false`, чтобы выполнять вызов только на стороне клиента. При первоначальной загрузке данные не будут получены до завершения гидратации, поэтому вам нужно обработать состояние ожидания, хотя при последующей навигации на стороне клиента данные будут ожидаться перед загрузкой страницы.

В сочетании с опцией `lazy` это может быть полезно для данных, которые не нужны при первом рендеринге (например, данные, не чувствительные к SEO).

```ts twoslash
/* Этот вызов выполняется до гидратации */
const articles = await useFetch('/api/article')

/* Этот вызов будет выполнен только на клиенте */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

Композабл `useFetch` предназначен для вызова в методе setup или прямого вызова на верхнем уровне функции в хуках жизненного цикла, иначе вам следует использовать [метод `$fetch`](#fetch).

### Минимизация размера полезной нагрузки

Опция `pick` помогает минимизировать размер полезной нагрузки, хранящейся в вашем HTML-документе, выбирая только те поля, которые вы хотите получить от композаблов.

```vue
<script setup lang="ts">
/* выбрать только поля, используемые в вашем шаблоне */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description']
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

Если вам нужен больший контроль или отображение нескольких объектов, вы можете использовать функцию `transform` для изменения результата запроса.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

::note
И `pick`, и `transform` не предотвращают первоначальное получение нежелательных данных. Но они предотвратят добавление нежелательных данных в полезную нагрузку, передаваемую с сервера клиенту.
::

:video-accordion{title="Посмотрите видео от Vue School о минимизации размера полезной нагрузки" videoId="1026410430" platform="vimeo"}

### Кэширование и повторное получение данных

#### Ключи

[`useFetch`](/docs/api/composables/use-fetch) и [`useAsyncData`](/docs/api/composables/use-async-data) используют ключи для предотвращения повторного получения одних и тех же данных.

- [`useFetch`](/docs/api/composables/use-fetch) использует предоставленный URL в качестве ключа. В качестве альтернативы значение `key` может быть предоставлено в объекте `options`, передаваемом в качестве последнего аргумента.
- [`useAsyncData`](/docs/api/composables/use-async-data) использует свой первый аргумент в качестве ключа, если это строка. Если первый аргумент - это функция-обработчик, которая выполняет запрос, то для вас будет сгенерирован ключ, уникальный для имени файла и номера строки экземпляра `useAsyncData`.

::tip
Чтобы получить кэшированные данные по ключу, вы можете использовать [`useNuxtData`](/docs/api/composables/use-nuxt-data)
::

:video-accordion{title="Посмотрите видео от Vue School о кэшировании данных с опцией key" videoId="1026410044" platform="vimeo"}

#### Общее состояние и согласованность опций

Когда несколько компонентов используют один и тот же ключ с `useAsyncData` или `useFetch`, они будут разделять одни и те же refs `data`, `error` и `status`. Это обеспечивает согласованность между компонентами, но требует, чтобы некоторые опции были согласованными.

Следующие опции **должны быть согласованными** во всех вызовах с одним и тем же ключом:
- функция `handler`
- опция `deep`
- функция `transform`
- массив `pick`
- функция `getCachedData`
- значение `default`

```ts
// ❌ Это вызовет предупреждение разработки
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
```

Следующие опции **могут безопасно отличаться** без вызова предупреждений:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ Это разрешено
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

Если вам нужны независимые экземпляры, используйте разные ключи:

```ts
// Это полностью независимые экземпляры
const { data: users1 } = useAsyncData('users-1', () => $fetch('/api/users'))
const { data: users2 } = useAsyncData('users-2', () => $fetch('/api/users'))
```

#### Реактивные ключи

Вы можете использовать вычисляемые refs, обычные refs или функции-геттеры в качестве ключей, что позволяет динамически получать данные, которые автоматически обновляются при изменении зависимостей:

```ts
// Использование вычисляемого свойства в качестве ключа
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value)
)

// Когда userId изменится, данные будут автоматически повторно получены
// и старые данные будут очищены, если их не используют другие компоненты
userId.value = '456'
```

#### Обновление и выполнение

Если вы хотите получить или обновить данные вручную, используйте функцию `execute` или `refresh`, предоставляемую композаблами.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">Обновить данные</button>
  </div>
</template>
```

Функция `execute` является псевдонимом для `refresh`, которая работает точно так же, но более семантична для случаев, когда получение данных [не немедленное](#not-immediate).

::tip
Для глобального обновления или аннулирования кэшированных данных см. [`clearNuxtData`](/docs/api/utils/clear-nuxt-data) и [`refreshNuxtData`](/docs/api/utils/refresh-nuxt-data).
::

#### Очистка

Если вы хотите очистить предоставленные данные по какой-либо причине, не зная конкретного ключа для передачи в `clearNuxtData`, вы можете использовать функцию `clear`, предоставляемую композаблами.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') clear()
})
</script>
```

#### Наблюдение

Чтобы повторно запускать вашу функцию получения данных каждый раз, когда изменяются другие реактивные значения в вашем приложении, используйте опцию `watch`. Вы можете использовать ее для одного или нескольких _наблюдаемых_ элементов.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Изменение id вызовет повторное получение данных */
  watch: [id]
})
</script>
```

Обратите внимание, что **наблюдение за реактивным значением не изменит получаемый URL**. Например, это будет продолжать получать тот же начальный ID пользователя, потому что URL создается в момент вызова функции.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id]
})
</script>
```

Если вам нужно изменить URL на основе реактивного значения, вы можете использовать [вычисляемый URL](#computed-url) вместо этого.

#### Вычисляемый URL

Иногда вам может потребоваться вычислить URL из реактивных значений и обновлять данные каждый раз, когда они изменяются. Вместо того чтобы жонглировать, вы можете прикрепить каждый параметр как реактивное значение. Nuxt автоматически будет использовать реактивное значение и повторно получать данные каждый раз, когда оно изменяется.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id
  }
})
</script>
```

В случае более сложного построения URL вы можете использовать обратный вызов как [вычисляемый геттер](https://vuejs.org/guide/essentials/computed.html), который возвращает строку URL.

Каждый раз, когда зависимость изменяется, данные будут получены с использованием вновь созданного URL. Объедините это с [не немедленным](#not-immediate), и вы можете подождать, пока реактивный элемент изменится, прежде чем получать данные.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false
})

const pending = computed(() => status.value === 'pending');
</script>

<template>
  <div>
    <!-- отключить ввод во время получения данных -->
    <input v-model="id" type="number" :disabled="pending"/>

    <div v-if="status === 'idle'">
      Введите ID пользователя
    </div>

    <div v-else-if="pending">
      Загрузка ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

Если вам нужно принудительно обновить данные при изменении других реактивных значений, вы также можете [наблюдать за другими значениями](#watch).

### Не немедленное выполнение

Композабл `useFetch` начнет получать данные в момент вызова. Вы можете предотвратить это, установив `immediate: false`, например, чтобы дождаться взаимодействия с пользователем.

При этом вам понадобятся и `status` для обработки жизненного цикла получения данных, и `execute` для запуска получения данных.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/

## Передача заголовков и cookies

Когда мы вызываем `$fetch` в браузере, пользовательские заголовки, такие как `cookie`, будут напрямую отправлены в API.

Обычно во время серверного рендеринга из соображений безопасности `$fetch` не включает cookies браузера пользователя и не передает cookies из ответа fetch.

Однако при вызове `useFetch` с относительным URL на сервере Nuxt будет использовать [`useRequestFetch`](/docs/api/composables/use-request-fetch) для проксирования заголовков и cookies (за исключением заголовков, которые не предназначены для пересылки, таких как `host`).

### Передача cookies из серверных API-вызовов в SSR-ответе

Если вы хотите передать/проксировать cookies в обратном направлении, из внутреннего запроса обратно клиенту, вам нужно будет обработать это самостоятельно.

```ts [composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Получаем ответ от серверной конечной точки */
  const res = await $fetch.raw(url)
  /* Получаем cookies из ответа */
  const cookies = res.headers.getSetCookie()
  /* Прикрепляем каждый cookie к нашему входящему запросу */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Возвращаем данные ответа */
  return res._data
}
```

```vue
<script setup lang="ts">
// Этот composable автоматически передаст cookies клиенту
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Поддержка Options API

Nuxt предоставляет способ выполнения загрузки `asyncData` в рамках Options API. Вы должны обернуть определение вашего компонента в `defineNuxtComponent`, чтобы это работало.

```vue
<script>
export default defineNuxtComponent({
  /* Используйте опцию fetchKey для предоставления уникального ключа */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::note
Использование `<script setup>` или `<script setup lang="ts">` является рекомендуемым способом объявления Vue компонентов в Nuxt.
::

:read-more{to="/docs/api/utils/define-nuxt-component"}

## Сериализация данных с сервера на клиент

При использовании `useAsyncData` и `useLazyAsyncData` для передачи данных, полученных на сервере, клиенту (а также всего остального, что использует [полезную нагрузку Nuxt](/docs/api/composables/use-nuxt-app#payload)), полезная нагрузка сериализуется с помощью [`devalue`](https://github.com/Rich-Harris/devalue). Это позволяет нам передавать не только базовый JSON, но также сериализовать и восстанавливать/десериализовать более сложные типы данных, такие как регулярные выражения, Dates, Map и Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` и `NuxtError` - и многое другое.

Также возможно определить собственный сериализатор/десериализатор для типов, которые не поддерживаются Nuxt. Подробнее об этом можно прочитать в документации [`useNuxtApp`](/docs/api/composables/use-nuxt-app#payload).

::note
Обратите внимание, что это _не применяется_ к данным, переданным из ваших серверных маршрутов при получении с помощью `$fetch` или `useFetch` - смотрите следующий раздел для получения дополнительной информации.
::

## Сериализация данных из API маршрутов

При получении данных из директории `server`, ответ сериализуется с помощью `JSON.stringify`. Однако, поскольку сериализация ограничена только примитивными типами JavaScript, Nuxt делает все возможное, чтобы преобразовать возвращаемый тип `$fetch` и [`useFetch`](/docs/api/composables/use-fetch) в соответствии с фактическим значением.

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" target="_blank"}
Узнайте больше об ограничениях `JSON.stringify`.
::

### Пример

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app.vue]
<script setup lang="ts">
// Тип `data` выводится как string, хотя мы вернули объект Date
const { data } = await useFetch('/api/foo')
</script>
```

### Пользовательская функция сериализации

Чтобы настроить поведение сериализации, вы можете определить функцию `toJSON` для возвращаемого объекта. Если вы определите метод `toJSON`, Nuxt будет учитывать возвращаемый тип функции и не будет пытаться преобразовать типы.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})

```

```vue [app.vue]
<script setup lang="ts">
// Тип `data` выводится как
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Использование альтернативного сериализатора

Nuxt в настоящее время не поддерживает альтернативный сериализатор для `JSON.stringify`. Однако вы можете вернуть свою полезную нагрузку как обычную строку и использовать метод `toJSON` для поддержания типобезопасности.

В примере ниже мы используем [superjson](https://github.com/blitz-js/superjson) в качестве нашего сериализатора.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Обходим преобразование типов
    toJSON() {
      return this
    }
  }

  // Сериализуем вывод в строку, используя superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` выводится как { createdAt: Date } и вы можете безопасно использовать методы объекта Date
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Рецепты

### Использование SSE (Server-Sent Events) через POST запрос

::tip
Если вы используете SSE через GET запрос, вы можете использовать [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) или VueUse композабл [`useEventSource`](https://vueuse.org/core/useEventSource/).
::

При использовании SSE через POST запрос вам необходимо обрабатывать соединение вручную. Вот как это можно сделать:

```ts
// Выполняем POST запрос к SSE эндпоинту
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: "Привет ИИ, как дела?",
  },
  responseType: 'stream',
})

// Создаем новый ReadableStream из ответа с TextDecoderStream для получения данных в виде текста
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Читаем фрагмент данных по мере их поступления
while (true) {
  const { value, done } = await reader.read()

  if (done)
    break

  console.log('Получено:', value)
}
```

### Выполнение параллельных запросов

Когда запросы не зависят друг от друга, вы можете выполнять их параллельно с помощью `Promise.all()` для повышения производительности.

```ts
const { data } = await useAsyncData(() => {
  return Promise.all([
    $fetch("/api/comments/"), 
    $fetch("/api/author/12")
  ]);
});

const comments = computed(() => data.value?.[0]);
const author = computed(() => data.value?.[1]);
```

:video-accordion{title="Посмотрите видео от Vue School о параллельной загрузке данных" videoId="1024262536" platform="vimeo"}